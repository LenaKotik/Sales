%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 34 47 574 780 
%%LanguageLevel: 2
%%Creator: CorelDRAW
%%Title: iPad Pro 11 Зад Full Vector L...
%%CreationDate: Fri Jan 10 15:17:03 2020
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: (atend)
%%EndComments
%%BeginProlog
/AutoFlatness false def
/AutoSteps 0 def
/CMYKMarks true def
/DocPsLevel 2 def
%Build: CorelDRAW Версия 21.3.0.758
/EpsFile true def
%%BeginResource: procset wCorel21Dict 21.0 0
/wCorel21Dict 300 dict def wCorel21Dict begin
%----------------------------------------------------------------------------
% Core Corel PostScript prolog functions
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
% Reduced syntax procedures
%----------------------------------------------------------------------------

/bd {bind def} bind def      				% bind proc names to current proc reference in the dict and define
/ld {load def} bd            				% load operator and define
/xd {exch def} bd            				% exchange operators on stack and define
/rp { {pop} repeat } bd      				% pop entries off stack iNumToPop rp
/dexec { exch begin cvx exec end } bd	% executes procedure from the dictionary on stack
/@cp /closepath ld
/@gs /gsave ld
/@gr /grestore ld
/@np /newpath ld
/Tl /translate ld
/$sv 0 def                   				% graphic state save snapshots
/@sv {/$sv save def}bd
/@rs {$sv restore}bd

/spg /showpage ld
/showpage {} bd

currentscreen                	% establish document's default halftone screen
/@dsp xd                     	% default spot func
/$dsp /@dsp def              	% default spot func name
/$dsa xd                     	% default screen angle
/$dsf xd                     	% default screen frequency function
/$sdf false def              	% FLAG: non-default screen for fill (true)
/$SDF false def              	% FLAG: non-default screen for stroke (true)
/$Scra 0 def                 	% screen adjustment (-90 if printing landscape)

/SetScr /setscreen ld					% sub in out own setscreen operator

/@ss                         	% Set Screen angle account for adjustment
{                            	% frequency angle proc
 2 index 0 eq
 {
  $dsf 3 1 roll              	% frequency angle proc deffreq
  4 -1 roll pop              	%
 } if                        	%
 exch $Scra add exch load    	% frequency angle+$Scra {proc}
 SetScr                   		%
} bd                         	%

/SeparationMode where					% init separatin mode
{ pop }{ /SeparationMode /Composite def } ifelse

/SeparationPlateName where		% init separation plate name
{ pop }{ /SeparationPlateName null def } ifelse

/SeparateInColor where				% init separtion in color flag
{ pop }{ /SeparateInColor false def	} ifelse


/EpsFile where								% are we an EPS file
{pop}
{/EpsFile false def} ifelse

/FillOverprint false def    % Fill overprint flag
/$fil 0 def                 % Fill type: 0:solid 1:pattern 2:fountain 3:PS 4:fountain shfill

/OutlineOverprint 0 def     % Outline overprint flag
/$PF false def              % pattern stroke flag(0 no pattern, 1 pattern)

/$bkg false def             % imaging background only flag
/CurrentOverprint false def % overprint flag

matrix currentmatrix        % establish current matrix
/$ctm xd                    % initial general transfo matrix

/$ptm matrix def            % pen stroking matrix(defaults identity)
/$ttm matrix def            % text transfo matrix(Corel extensions)
/$stm matrix def            % "save" matrix in extended text(Corel extensions)

/$ffpnt true def						% flag for painting fountain strips (overprint prob)

%----------------------------------------------------------------------------
% Corel re-encoding vector
%----------------------------------------------------------------------------
/CorelDrawReencodeVect [
16#0/grave 16#5/breve 16#6/dotaccent 16#8/ring 16#A/hungarumlaut 16#B/ogonek 16#C/caron
16#D/dotlessi 16#27/quotesingle 16#60/grave 16#7C/bar 16#80/Euro
16#82/quotesinglbase/florin/quotedblbase/ellipsis/dagger/daggerdbl
16#88/circumflex/perthousand/Scaron/guilsinglleft/OE
16#91/quoteleft/quoteright/quotedblleft/quotedblright/bullet/endash/emdash
16#98/tilde/trademark/scaron/guilsinglright/oe
16#9F/Ydieresis
16#A1/exclamdown/cent/sterling/currency/yen/brokenbar/section
16#a8/dieresis/copyright/ordfeminine/guillemotleft/logicalnot/minus/registered/macron
16#b0/degree/plusminus/twosuperior/threesuperior/acute/mu/paragraph/periodcentered
16#b8/cedilla/onesuperior/ordmasculine/guillemotright/onequarter/onehalf/threequarters/questiondown
16#c0/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
16#c8/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis
16#d0/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis/multiply
16#d8/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute/Thorn/germandbls
16#e0/agrave/aacute/acircumflex/atilde/adieresis/aring/ae/ccedilla
16#e8/egrave/eacute/ecircumflex/edieresis/igrave/iacute/icircumflex/idieresis
16#f0/eth/ntilde/ograve/oacute/ocircumflex/otilde/odieresis/divide
16#f8/oslash/ugrave/uacute/ucircumflex/udieresis/yacute/thorn/ydieresis
] def

%----------------------------------------------------------------------------
% Proc:  get_ps_level
% Stack: get_ps_level pslevel
% Desc:  returns level of PS interpreter environemnt
%----------------------------------------------------------------------------
/get_ps_level
	/languagelevel where
	{
		pop systemdict /languagelevel get exec
	}
	{
		1
	} ifelse
def

%----------------------------------------------------------------------------
% Level 2 or 3 flag
%----------------------------------------------------------------------------
/Level2 get_ps_level 2 ge def

%----------------------------------------------------------------------------
% Level 3 flag
%----------------------------------------------------------------------------
/Level3 get_ps_level 3 ge def

%----------------------------------------------------------------------------
% Flag to indicate we are processed by AdobeDistiller
%----------------------------------------------------------------------------
/AdobeDistiller
  /product where
  {
    pop systemdict/setdistillerparams known product (Adobe PostScript Parser) ne and
  }
  {
    false
  }ifelse
def

%----------------------------------------------------------------------------
% Flag to indicate we are are being separated in-RIP (not by Distiller!)
%----------------------------------------------------------------------------
/InRipSeparation
  AdobeDistiller
  {
    false										% we are being distilled by Adobe Distiller, not RIP
  }
  {
    Level2									% in-RIP separations allowed for Level2 and higher
    {
      currentpagedevice/Separations 2 copy known		% check currentpage dict - Separations should be set true
      {
        get
      }
      {
        pop pop false
      }ifelse
    }
    {
     false
    }ifelse
  }	ifelse
def

%----------------------------------------------------------------------------
% Flag to indicate we are being separated through overloaded
% setcmykcolor/currentcmykcolor operators, Level 1 style
%----------------------------------------------------------------------------
/ColorSeparationLevel1

	% try to set pure Cyan, Magenta, Yellow and Black colors and see whether system knock one of the colors

	1 0 0 0 gsave setcmykcolor currentcmykcolor grestore add add add 0 ne
	0 1 0 0 gsave setcmykcolor currentcmykcolor grestore add add add 0 ne
	0 0 1 0 gsave setcmykcolor currentcmykcolor grestore add add add 0 ne
	0 0 0 1 gsave setcmykcolor currentcmykcolor grestore add add add 0 ne
	and and and not
def

%----------------------------------------------------------------------------
% Flag to indicate we are being separated (does not matter by which method)
%----------------------------------------------------------------------------
/ColorSeparation
  /LumSepsDict where            % see if we're being separated by TrapWise or PressWise
  {
    pop                         % lose the dictionary
    false                       % return false
  }
  {
    /AldusSepsDict where        % they might also use this one (Mac vs. PC?)
    {
      pop                       % lose the dictionary
      false                     % return false
    }
    {                           % we're not being separated by TrapWise or PressWise, use a generic method
      InRipSeparation						% is in-RIP (Level2 style) separation
      {
        true
      }
      {
        % is Level 1 style separation, through overloaded setcmykcolor currentcmykcolor operators
		ColorSeparationLevel1
      }ifelse
    }ifelse
  }ifelse
def

%----------------------------------------------------------------------------
% Flag to indicate that PS device has color capabilities
%----------------------------------------------------------------------------
/IsColorDevice
	/deviceinfo where
	{
		pop deviceinfo /Colors known
		{
			deviceinfo /Colors get exec 1 gt
		}
		{
			false
		}ifelse
	}
	{
		/statusdict where
		{
			pop statusdict /processcolors known
			{
				statusdict /processcolors get exec 1 gt
			}
			{
				false
			}ifelse
		}
		{
			false
		}ifelse
	} ifelse
def

%----------------------------------------------------------------------------
% Proc:		get_simulate_devicen
% Stack:	--> get_simulate_devicen --> bool
%					bool true - smiluate DeviceN through overprinting on Level 2
% Desc:		determines if we should simulate DeviceN colors through overprints thus
%					preserving spot colors on Level 2 devices in composite mode
%----------------------------------------------------------------------------
/get_simulate_devicen
  get_ps_level 2 eq							% we simulate DeviceN only on Level2
  {
    {
			SeparationMode /OnHost ne								% no DeviceN simulation for on-host separations mode
			InRipSeparation AdobeDistiller or and		% do it for in-RIP separation or distilling
    } bind
  }
  {
    false
  }ifelse
def

%----------------------------------------------------------------------------
%
%	Color objects definition section
%
%----------------------------------------------------------------------------

% Default document colorspaces
/DocGrayScaleSpace [/DeviceGray] def
/DocRgbSpace [/DeviceRGB] def
/DocCmykSpace [/DeviceCMYK] def

/DocLabSpace
[
	/CIEBasedABC
	<<
	/BlackPoint [0 0 0]
	/WhitePoint [ 0.9637  1.0000  0.8241 ]
	/RangeABC [0 100 -128 127 -128 127]
	/DecodeABC [{16 add 116 div} bind {500 div} bind {200 div} bind]
	/MatrixABC [1 1 1 1 0 0 0 0 -1]
	/DecodeLMN
	[
		{dup 0.206897 ge{dup dup mul mul}{0.137931 sub 0.128419 mul} ifelse  0.9637 mul }bind 
		{dup 0.206897 ge{dup dup mul mul}{0.137931 sub 0.128419 mul} ifelse  1.0000 mul }bind 
		{dup 0.206897 ge{dup dup mul mul}{0.137931 sub 0.128419 mul} ifelse  0.8241 mul }bind 
	]
	>>
] def

%----------------------------------------------------------------------------
% Proc:		validate_cie_colorspace_whitepoint
% Stack: 	colorspacedict --> validate_cie_colorspace_whitepoint --> colorspacedict
% Desc: 	validates CIE colorspace white point, the Yw parameter must be 1.0
%----------------------------------------------------------------------------
/validate_cie_colorspace_whitepoint
{
	load dup aload pop
	/WhitePoint get
	1 1.0 put pop
} bd

%----------------------------------------------------------------------------
% Proc:		set_cie_colorspaces
% Stack: 	none
% Desc: 	sets document color spaces to the CIE CSA, if exist
%----------------------------------------------------------------------------
/set_cie_colorspaces
{
	/DocGrayScaleSpaceCIE where
	{
		pop
		/DocGrayScaleSpaceCIE validate_cie_colorspace_whitepoint /DocGrayScaleSpace xd
		
		% modify CIEBasedA definition for /DecodeA key written by ICM
		% it is an array while should be a procedure, PS interpreters will fail otherwise
		DocGrayScaleSpace aload pop
		begin pop
			/DecodeA where
			{
				pop
				DecodeA type /arraytype eq
				{
					DecodeA aload pop
					/DecodeA exch def			
				}if
			}if
		end
	}if

	/DocRgbSpaceCIE where
	{	
		pop
		/DocRgbSpaceCIE validate_cie_colorspace_whitepoint /DocRgbSpace xd
	}if

	/DocCmykSpaceCIE where
	{
		pop
		/DocCmykSpaceCIE validate_cie_colorspace_whitepoint /DocCmykSpace xd
	}if
} bd

%----------------------------------------------------------------------------
% Proc:		set_rendering_intent
% Stack: 	rendering_intent set_rendering_intent
%			rendering_intent - either /Perceptual, /AbsoluteColorimetric,
%			/RelativeColormetric or /Saturation
% Desc: 	sets prefered rendring intent to use in CRD on device
%----------------------------------------------------------------------------
/set_rendering_intent
{
	Level3
	{
		findcolorrendering
		{
			% CRD found for requested rendering intent and device settings
			/ColorRendering findresource setcolorrendering 
		}
		{
			% CRD not found for requested rendering intent
			dup /DefaultColorRendering eq
			{ 
				pop
			}
			{
				/ColorRendering findresource setcolorrendering 
			}
		}ifelse 
	}
	{
		pop
	}ifelse
} bd

%----------------------------------------------------------------------------
% Proc:	findcmykcustomcolor
% Stack: 	c m y k name --> findcmykcustomcolor --> array
%				c - cyan color component
%				m - magenta color component
%				y - yellow color component
%				k - black color component
%				(name) - spot color name
% Desc: 	finds spot color object defined by the name, if no fyndcmykcutomcolor
%				is defined on the system  just stores alternative CMYK values and name
%				in the array to be used by setcustomcolor procedure
%----------------------------------------------------------------------------
/findcmykcustomcolor where
{
  pop
}
{
  /findcmykcustomcolor
  {
    5 array astore
  } def
} ifelse

%----------------------------------------------------------------------------
% Proc:	setcustomcolor
% Stack: 	array tint --> setcustomcolor
%				array - color array returned by findcmykcustomcolor
%				tint - color component value
% Desc: 	sets custom ink ( spot ) color or its alternative CMYK representation
%				if spot color is not available on the system (printer/RIP)
%----------------------------------------------------------------------------
/setcustomcolor where
SeparationMode /OnHost ne and
{
  pop
}
{
	%----------------------------------------------------------------------------
	% Stack: 	tint cyan magenta yellow black tint_cmyk_color cyan1 magenta1 yellow1 black1
	% Desc: 	tint color
	%----------------------------------------------------------------------------
	/tint_cmyk_color
	{
		 5 -1 roll
		 dup 1 ge                    	% see if tint >= 1
		 {pop}                       	% if it is, pop it
		 {                           	% otherwise, multiply all 4 components
			4
			{
				dup                   	% duplicate the tint
				6 -1 roll              	% get next component
				mul                    	% multiply with current tint
				exch                    % tint back on top
			}repeat
			pop                        	% no need for tint anymore
		 } ifelse
	} bd  
  
	%----------------------------------------------------------------------------
	% Stack: 	c m y k setprocesscolor_5 -
	% Desc: 	sets process color without doing any separations
	%			we assume color has been preseparated
	%----------------------------------------------------------------------------
	/setprocesscolor_5
	{
		SepMode_5 0 eq              % Check if not performing color seps.
		{
			SetCmyk_5               % set CMYK color
		}
		{
			SepsColor not         	% separating in grayscale
   			{
				4 1 roll pop pop pop	% leave just K component on stack
				1 exch sub SetGry		%	set gray component		
			}
			{
				SetCmyk_5               % set CMYK color for separations in color
			}ifelse
		}ifelse
	} bd	
  
	/setcustomcolor
	{
  		exch
    	aload pop
    	SepMode_5 0 eq
    	{
     		pop
     		tint_cmyk_color
     		setprocesscolor_5
    	}
    	{
     		CurrentInkName_5 eq
     		{
      			4 index
     		}
     		{
      			0
     		}ifelse
     		6 1 roll
     		5 rp
     		1 sub neg SetGry
    	}ifelse
   } bd 

} ifelse

%----------------------------------------------------------------------------
% Proc:		convert_rgb_to_cmyk
% Stack: 	r g b ConvDict convert_rgb_to_cmyk c m y k
%					r - red
%					g - green
%					b - blue
%					ConvDict - conversion dictionary with RGB-CMYK look up table (LUT)
%					c - cyan
%					m - magenta
%					y - yellow
%					k - black
% Desc: 	converts rgb color values to cmyk color values using either RGB-to-CMYK
%					look up table	if supplied, or primitive conversion formulae
%----------------------------------------------------------------------------
/convert_rgb_to_cmyk
{
 dup type /dicttype eq
 {
 }
 {
  3                         %
  {                         % r g b
    1 exch sub              % r g 1-b       	% y = 1 - b
    3 1 roll                % y r g
  } repeat                  % c m y
  3 copy                    % c m y c m y
  min min                   % c m y min(c,m,y)     	% K=min(c,m,y)
  3                         %
  {                         % c m y K
    dup 5 -1 roll           % m y K K c
    sub neg                 % m y K c-K     	% C = c - K
    exch                    % m y C K
  } repeat                  % C M Y K
 } ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		colorspace safe_setcolorspace
% Stack: 	colorspace --> safe_setcolorspace -->
% 				colorspace colorspace to set
% Desc: 	set colorspace, unless it is already current colorspace
%----------------------------------------------------------------------------
/safe_setcolorspace
{
  dup
  currentcolorspace eq
  {
    pop
  }
  {
    setcolorspace

  }ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		safe_setoverprint
% Stack:	overprintflag safe_setoverprint
%					overprintflag - boolean or integer
% Desc:		sets current color performing separations if necessary
%----------------------------------------------------------------------------
/safe_setoverprint
{
	dup type /booleantype eq			% boolean flag is passed
  {
    dup
    currentoverprint ne
    {
			setoverprint
		}
    {
			pop
		}
    ifelse
  }
  {															% integer flag is passed
		1 eq setoverprint
	}
  ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		is_cmyk_channel_name
% Stack: 	channelName --> is_cmyk_channel_name --> bool
%			channelName - name of the channel
% Desc: 	determines whether channel name on stack belong to cmyk color
%----------------------------------------------------------------------------
/is_cmyk_channel_name
{
	/channel_name xd

	channel_name /Cyan eq
	channel_name /Magenta eq or
	channel_name /Yellow eq or
	channel_name /Black eq or
	{
		true		
	}
	{
		false
	}ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		is_rgb_channel_name
% Stack: 	channelName --> is_rgb_channel_name --> bool
%			channelName - name of the channel
% Desc: 	determines whether channel name on stack belong to RGB color
%----------------------------------------------------------------------------
/is_rgb_channel_name
{
	/channel_name xd

	channel_name /Red eq
	channel_name /Green eq or
	channel_name /Blue eq or
	{
		true		
	}
	{
		false
	}ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		is_spot_channel_name
% Stack: 	channelName --> is_spot_channel_name --> bool
%			channelName - name of the channel
% Desc: 	determines whether channel name on stack belong to spot color
%----------------------------------------------------------------------------
/is_spot_channel_name
{
	/channel_name xd

	channel_name is_cmyk_channel_name
	channel_name is_rgb_channel_name or
	channel_name /Gray eq or
	{
		false		
	}
	{
		true
	}ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		spot_tint_transform_proc
% Stack: 	tint  [ alternativeColors ] alternativeSpace --> spot_tint_transform_proc -- > tinted spot color in alternative color space
%			alternativeSpace - alternative color space ( e.g. /DocGrayScaleSpace, /DocRgbSpace, /DocCmykSpace )
%			[ alternative color values ] - spot color values in alternative color space
%			tint - tint of spot color [ 0.. 1.0]
% Desc: 	applies tint to spot ink's alternative color space values
%----------------------------------------------------------------------------
/spot_tint_transform_proc
{
	/alternativeSpace xd
	/alternativeColors xd
	/tint xd
	
	alternativeSpace DocLabSpace eq
	{
		/mixMethod /Additive def
		/altSpaceNumChannels 3 def
	}
	{
	  alternativeSpace DocCmykSpace eq
	  {
		/mixMethod /Subtractive def
		/altSpaceNumChannels 4 def
	  }
	  {
		alternativeSpace DocRgbSpace eq
		{
		  /mixMethod /Additive def
		  /altSpaceNumChannels 3 def
		}
		{
		  alternativeSpace DocGrayScaleSpace eq
		  {
			/mixMethod /Additive def
			/altSpaceNumChannels 1 def
		  } if
		} ifelse
	  }ifelse
	}ifelse

  	% apply tint on spot's alt color values

  	alternativeSpace DocLabSpace eq
	{
		% for LAB tint just colorant values, leave lightness alone
		alternativeColors aload pop
		tint mul 3 1 roll
		tint mul 3 1 roll
		dup 100 exch sub 1 tint sub mul add 3 1 roll
	}
	{
  		/tintedColor altSpaceNumChannels {0.0} repeat altSpaceNumChannels array astore def
		
		0 1 altSpaceNumChannels 1 sub
		{
			/altChannelIndex exch def
			
			alternativeColors altChannelIndex get
			
			% tint every channel
			mixMethod /Additive eq
			{
				1.0 exch sub tint mul
				1.0 exch sub
			}
			{
				tint mul
			}ifelse
			
			tintedColor altChannelIndex 3 2 roll put
		}for
		
		tintedColor aload pop
	}ifelse
  
} bd

%----------------------------------------------------------------------------
% Proc:	devicen_colorant_mixer_proc
% Stack: 	colorant1... colorantN  [ alternativeColor ] [names] alternativeSpace  N --> colorant_mixer_proc -- > mixedColor
%			N - number of colorants
%			alternativeSpace - alternative color space ( e.g. /DocGrayScaleSpace, /DocRgbSpace, /DocCmykSpace )
%			colorant i - colorant values
%			alternativeColor N - colorant representation in alternative colorspace
%			names N - alternative color plate names
%			mixedColor - mixed color in alternativeColorspace
% Desc: 	mixes colorants to produce color representation in alternative color space
%----------------------------------------------------------------------------
/devicen_colorant_mixer_proc
{
	/numChannels xd
	/alternativeSpace xd
	/channelNames xd
	/alternativeColors xd
	numColorants array astore /colorants xd

	/is_spot_channel_name_loc { is_spot_channel_name } bind def
	
	alternativeSpace DocCmykSpace eq
	{
		/mixMethod /Subtractive def
		/altSpaceNumChannels 4 def
		/is_spot_channel_name_loc { is_cmyk_channel_name not } bind def
	}
	{
		alternativeSpace DocRgbSpace eq
		{
			/mixMethod /Additive def
			/altSpaceNumChannels 3 def
			/is_spot_channel_name_loc { is_rgb_channel_name not } bind def
		}
		{
			alternativeSpace DocGrayScaleSpace eq
			{
				/mixMethod /Additive def
				/altSpaceNumChannels 1 def
				/is_spot_channel_name_loc { /Gray ne } bind def
			} if
		} ifelse
	}ifelse

  % iterate over all components of alternative color space
  mixMethod /Additive eq
  {
	/mixedColor altSpaceNumChannels {0.0} repeat altSpaceNumChannels array astore def

	/bProcessPlateTinted false def
	
	0 1 numChannels 1 sub
	{
		/channelIndex exch def

		channelNames channelIndex get is_spot_channel_name_loc
		/bSpotChannel xd	
		/sourceChannel colorants channelIndex get def								% colorant [channelIndex]
		
		/bWhiteBackground
			0 mixedColor {add} forall
			altSpaceNumChannels div
			0.999 gt bProcessPlateTinted and
		def
		
		bSpotChannel bProcessPlateTinted not and
		{
			/bSpotChannel false def
		}if
		
		0 1 altSpaceNumChannels 1 sub
		{
			/altChannelIndex exch def
			/mixedChannel mixedColor altChannelIndex get def

			sourceChannel
			alternativeColors channelIndex get altChannelIndex get 	% alternativeColor[channelIndex][altChannelIndex]
			1.0 exch sub mul
			1.0 exch sub
		
			dup 1.0 gt { pop 1.0 }if
			dup 0.0 lt { pop 0.0 }if
			
			bSpotChannel
			{
				sourceChannel 0.0 gt
				{
					% paints area covered by spot
					mixedChannel mul
				}
				{
					% paints area not covered by spot ink
					pop mixedChannel
				}ifelse
			}
			{
				/bProcessPlateTinted true def

				globaldict begin
					/bSkipDeviceNImage where
					{
						pop false
					}
					{
						true
					}
					ifelse
				end
				
				DevicenImage and
				{
					pop

					sourceChannel
					alternativeColors channelIndex get altChannelIndex get 	% alternativeColor[channelIndex][altChannelIndex]
					mul
					
					mixedChannel add
				}
				{
					mixedChannel add
				}ifelse
			}ifelse
			
			dup 1.0 gt { pop 1.0 }if
			dup 0.0 lt { pop 0.0 }if
			mixedColor altChannelIndex 3 2 roll put
		}for
	}for
  }
  {
	/mixedColor altSpaceNumChannels {1} repeat altSpaceNumChannels array astore def

	0 1 altSpaceNumChannels 1 sub
	{
		/targetIndex exch def

		% iterate over all colorants of original colorspace
		0 1 numColorants 1 sub
		{
		  /sourceIndex exch def
		  colorants sourceIndex get								%  colorant [sourceIndex]
		  alternativeColors sourceIndex get targetIndex get 	% alternativeColor[sourceIndex][targetIndex]

		  mul
		  1 exch sub

		  mixedColor targetIndex get mul mixedColor targetIndex 3 2 roll put
		} for

		mixedColor targetIndex 1 mixedColor targetIndex get sub put
		
	} for
  } ifelse

  mixedColor aload pop
} bd


%----------------------------------------------------------------------------
% Colorspec dictionary definition
% Grayscale, RGB, HSB, CMYK, Lab, Spot, DeviceN and Registration color dictionaries
% are created by replicating and extending abstract ColorSpec dictionary
%----------------------------------------------------------------------------
/ColorSpec
  9 dict begin
		/color [] def					% color component values
		/names [] def					% color components names - reserved : (Cyan ) (Magenta) (Yellow) (Black) (Red) (Green) (Blue) (All)
		/num 0 def						% number of color components/names
		/ColorModel	null def	% color model : /Grayscale /Rgb /Cmyk /Spot /DeviceN /Registration
		/ColorSpace [] def		% CSA or device colorspace array

		%----------------------------------------------------------------------------
		% Stack: 	--> set_color -->
		% Desc: 	sets color as current
		%----------------------------------------------------------------------------
		/set_color
		{
			ColorSeparationLevel1
			{
				convert_to_cmyk /color get aload pop setcmykcolor
			}
			{
				ColorSpace safe_setcolorspace
				color aload pop setcolor
			}
			ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_set_color --> bool
		%					bool - painting flag : true - paint, false - do not paint
		% Desc: 	separates color, if necessary, and sets as current. Painting
		%					flag is set according whether separation to current plate happened
		%					and overprint settings
		%----------------------------------------------------------------------------
		/separate_set_color
		{
			SeparationMode /OnHost eq
			{
				separate_color
				{
				 /set_color dexec true
				}
				{
					pop							% remove colorspec on stack
					currentoverprint
					{
						false					% overprint flag is on, do not knockout
					}
					{
						% overprint flag is off, knockout
						SeparateInColor
						{
							% knockout - paint white CMYK object
							0 0 0 0 SetCmyk_5 true
						}
						{
							% knockout - paint white grayscale object
							1 SetGry true
						} ifelse
					} ifelse
				} ifelse
			}
			{
				set_color true
			} ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color	{ currentdict false } bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk { currentdict } bd

	currentdict end
def

%----------------------------------------------------------------------------
% Grayscale color dictionary definition
%----------------------------------------------------------------------------
/GrayscaleColorSpec
	ColorSpec 9 dict copy
  begin
		/names {/Black} def									% color components names
		/num 1 def													% number of color components/names
		/ColorModel	/Grayscale def					% color model
		/ColorSpace DocGrayScaleSpace def		% CSA or device colorspace array

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			currentdict false

			SeparationMode /OnHost eq
			{
				SeparationPlateName /Black eq
				{
					SeparateInColor
					{
						pop convert_to_cmyk true
					}
					{
						pop true
					} ifelse
				}if
			}if
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			0 0 0 color aload pop 1 exch sub create_cmyk_color
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_grayscale_color
% Stack: 	tint --> create_grayscale_color -- >colorspec
%				tint - gray component value
%				colorspec - colorspec dicitonary
% Desc: 	creates grayscale color dictionary
%----------------------------------------------------------------------------
/create_grayscale_color
{
	GrayscaleColorSpec 9 dict copy
	begin
		/color exch 1 array astore def			% color component values
		/ColorSpace DocGrayScaleSpace def		% document Grayscale color space 	
	currentdict end
} bd

%----------------------------------------------------------------------------
% RGB color dictionary definition
%----------------------------------------------------------------------------
/RgbColorSpec
	ColorSpec 9 dict copy
  begin
    /names {/Red /Green /Blue} def		% color components names
    /num 3 def												% number of color components/names
		/ColorModel	/Rgb def							% color model
    /ColorSpace DocRgbSpace def				% CSA or device colorspace array

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			convert_to_cmyk /separate_color dexec
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			color aload pop convert_rgb_to_cmyk create_cmyk_color
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_rgb_color
% Stack: 	r g b --> create_rgb_color -- >colorspec
%				r, g, b - Red, Green, Blue color components respectively
%				colorspec - colorspec dicitonary
% Desc: 	creates RGB color dictionary
%----------------------------------------------------------------------------
/create_rgb_color
{
	RgbColorSpec 9 dict copy
	begin
		3 array astore /color exch def		% color component values
		/ColorSpace DocRgbSpace def			% document RGB color space 	
	currentdict end
} bd

%----------------------------------------------------------------------------
% HSB color dictionary definition
% HSB is a math transform of RGB color model and is represented by RGB color space
%----------------------------------------------------------------------------
/HsbColorSpec
	ColorSpec 9 dict copy
  begin
    /names {/Hue /Saturation /Brightness} def		% color components names
    /num 3 def												% number of color components/names
		/ColorModel	/Hsb def							% color model
    /ColorSpace DocRgbSpace def				% CSA or device colorspace array

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			convert_to_cmyk /separate_color dexec
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			color aload pop
			hsb2rgb
			convert_rgb_to_cmyk create_cmyk_color
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_rgb --> colorspec
		% Desc: 	converts current colorspec to RGB colorspec
		%----------------------------------------------------------------------------
		/convert_to_rgb
		{
			color aload pop
			hsb2rgb
			create_rgb_color
		} bd

	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_hsb_color
% Stack: 	h s b --> create_hsb_color -- >colorspec
%				h, s, b - Hue, Saturation, Brightness color components respectively
%				colorspec - colorspec dicitonary
% Desc: 	creates HSB color dictionary
%----------------------------------------------------------------------------
/create_hsb_color
{
	HsbColorSpec 9 dict copy
	begin
		3 array astore /color exch def		% color component values
		/ColorSpace DocRgbSpace def				% document RGB color space 	
	currentdict end
} bd

%----------------------------------------------------------------------------
% CMYK color dictionary definition
%----------------------------------------------------------------------------
/CmykColorSpec
  ColorSpec 9 dict copy													% copy colorspec
  begin
    /names {/Cyan /Magenta /Yellow /Black} def	% color components names
    /num 4 def																	% number of color components/names
 		/ColorModel	/Cmyk def												% color model
    /ColorSpace DocCmykSpace def								% CSA or device colorspace array

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			currentdict false

			SeparationPlateIndex 0 ge
			SeparationPlateIndex 3 le and
			{
				color SeparationPlateIndex get	% get tint on current separation plate

				dup 0 gt
				{
					3 1 roll pop pop
					% tint on current plate is not zero - have separation
					SeparateInColor
					{
						% move tint to SeparationPlateIndex position in CMYK color
						% so for example Cyan plate will print in pure cyan CMYK
						% color instead of default grayscale

						0 0 0 4 SeparationPlateIndex roll create_cmyk_color true
					}
					{
						% separate to grayscale color
						1 exch sub create_grayscale_color true
					} ifelse
				}
				{
					pop
				} ifelse
			} if
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			% it is CMYK already, return current colorspec
			currentdict
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_cmyk_color
% Stack: 	c m y k --> create_cmyk_color -- >colorspec
%				c, m, y, k - Cyan, Magenta, Yellow and Black color components respectively
%				colorspec - colorspec dicitonary
% Desc: 	creates CMYK color dictionary
%----------------------------------------------------------------------------
/create_cmyk_color
{
  CmykColorSpec 9 dict copy
  begin
    4 array astore /color exch def			% color component values
	/ColorSpace DocCmykSpace def			% document CMYK color space 	
  currentdict end
} bd

%----------------------------------------------------------------------------
% Spot color dictionary definition
%----------------------------------------------------------------------------
/SpotColorSpec
  ColorSpec 9 dict copy
  begin
    /num 1 def											% number of color components/names
		/ColorModel	/Spot def						% color model

		%----------------------------------------------------------------------------
		% Stack: 	--> set_color -->
		% Desc: 	sets color as current
		%----------------------------------------------------------------------------
		/set_color
		{
			ColorSeparationLevel1
			{
				color aload pop get_cmyk_alternative_color /color get aload pop names aload pop findcmykcustomcolor exch setcustomcolor
			}
			{
				ColorSpace safe_setcolorspace
				color aload pop setcolor
			}
			ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			currentdict false					% retvalue - default case, no separation
			SeparationPlateIndex 4 eq			% make sure current plate is spot plate
			{
				names aload pop SeparationPlateName eq
				{
					color aload pop						% get tint on current spot separation plate
					dup 0 gt							% duplicate tint value to be consumed by comparison
					{
						% remove current color and retvalue from stack
						3 1 roll pop pop

						% tint is not zero - we have separation
						SeparateInColor
						{
							% convert color to CMYK to paint separation in color
							pop convert_to_cmyk true
						}
						{
							% separate to gray color
							1 exch sub create_grayscale_color true
						} ifelse
					}
					{
						pop % remove duplicated tint from stack
					} ifelse
				} if
			} if
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			/alternativeSpace ColorSpace 2 get def		% get alternative colorspace
			/tintTransformProc ColorSpace 3 get def		% get tint transformation procedure

			alternativeSpace DocCmykSpace eq
			{
				% alternative space is CMYK, create CMYK color from alternative color values
				color aload pop tintTransformProc create_cmyk_color
			}
			{
				alternativeSpace DocRgbSpace eq
				{
					% alternative space is RGB, create RGB color from alternative color values
					% and convert RGB color to CMYK
					color aload pop tintTransformProc create_rgb_color /convert_to_cmyk dexec
				}
				{
					alternativeSpace DocGrayScaleSpace eq
					{
						% alternative space is grayscale, invert spot tint and use as K component of CMYK color
						0 0 0 color aload pop 1 sub create_cmyk_color
					}
					{
						0 0 0 1 create_cmyk_color
					}ifelse
				} ifelse
			} ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> get_cmyk_alternative_color --> colorspec
		% Desc: 	obtains CMYK representation of this spot color
		%----------------------------------------------------------------------------
		/get_cmyk_alternative_color
		{
			/alternativeSpace ColorSpace 2 get def		% get alternative colorspace

			alternativeSpace DocCmykSpace eq
			{
				% alternative space is CMYK, create CMYK color from alternative color values
				alternativeColor aload pop create_cmyk_color
			}
			{
				alternativeSpace DocRgbSpace eq
				{
					% alternative space is RGB, create RGB color from alternative color values
					% and convert RGB color to CMYK
					alternativeColor  aload pop create_rgb_color /convert_to_cmyk dexec
				}
				{
					alternativeSpace DocGrayScaleSpace eq
					{
						% alternative space is grayscale
						alternativeColor  aload pop create_grayscale_color /convert_to_cmyk dexec
					} 
					{
						0 0 0 1 create_cmyk_color
					}ifelse
				} ifelse
			} ifelse
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_spot_colorspace
% Stack: 	name [alternativeColor] alternativeSpace  --> create_spot_colorspace -- > colorspace
%				name - spot color name
%				alternativeSpace - alternative colorspace (/DocGrayScaleSpace, /DocRgbSpace, /DocCmykSpace )
%				alternativeColor - spot color representation in alternative colorspace
% Desc: 	creates spot ( named ) colorspace
%----------------------------------------------------------------------------
/create_spot_colorspace
{
  load /alternativeSpace xd
  /alternativeColor xd
  /name xd
 
  [ /Separation name alternativeSpace [ alternativeColor alternativeSpace /spot_tint_transform_proc cvx ] cvx ]
} bd

%----------------------------------------------------------------------------
% Proc:		create_spot_color
% Stack:	tint spotSpace --> create_spot_color -- >colorspec or
%         tint name [alternativeColor] alternativeSpace --> create_spot_color -- >colorspec or
%						tint - spot color ink value
%						name - spot color name
%						alternativeColor - spot color representation in alternative colorspace
%						alternativeSpace - alternative colorspace (/DocGrayScaleSpace, /DocRgbSpace, /DocCmykSpace )
% Desc: 	creates spot ( named ) colorspec. Uses spot colorspace on stack or creates
% 				new colorspace from stack parameters
%----------------------------------------------------------------------------
/create_spot_color
{
	SpotColorSpec 9 dict copy
  begin
 		dup type /arraytype ne
    {
			create_spot_colorspace				% create spot colorspace from stack parameters
    } if
		/ColorSpace xd
    /color exch 1 array astore def	% color component values
    ColorSpace 1 get 1 array astore
    /names xd												% spot color name
  currentdict end
} bd

%----------------------------------------------------------------------------
% DeviceN color dictionary definition
% Inherited from SpotColorSpec as there are strong similarities between
% spot and DeviceN colors, spot being 1 ink DeviceN color
%----------------------------------------------------------------------------
/DevicenColorSpec
  SpotColorSpec 9 dict copy
  begin
		/ColorModel	/DeviceN def							% color model

    %----------------------------------------------------------------------------
		% Stack: 	--> set_color -->
		% Desc: 	separates color, if necessary, and sets as current
		%----------------------------------------------------------------------------
		/set_color
		{
			Level3
			{
				% Level 3 support DeviceN colors natively
				ColorSpace safe_setcolorspace
				color aload pop setcolor
			}
			{
				% for Level 2 output color in alternative colorspace
				ColorSpace 2 get setcolorspace
				color aload pop ColorSpace 3 get exec setcolor
			} ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			currentdict false			% default case - no separation

			/PlateIndex -1 def

			0 1 num 1 sub
			{
				dup
				names exch get SeparationPlateName eq
				{
					/PlateIndex xd
					exit
				} if
				pop
			} for

			PlateIndex 0 ge
			{
				color PlateIndex get														% get separation ink tint
				dup 0 gt
				{
					% tint not zero - have separation
					SeparateInColor
					{
						% convert DeviceN plate color to CMYK to paint separation in color

						% leave only separation component in DeviceN
						num 1 sub {0} repeat num PlateIndex roll

						% create temp DeviceN color with single component and convert it to DeviceN
						ColorSpace create_devicen_color /convert_to_cmyk dexec true
					}
					{
						% separate to gray color
						1 exch sub create_grayscale_color true
					} ifelse
					4 2 roll pop pop
				}
				{
					pop
				} ifelse
			} if
		} bd

    %----------------------------------------------------------------------------
		% Stack: 	i --> get_ink_as_spot --> colorspec
		%					i - DeviceN colorant index
		%					colorspec - DeviceN colorant as spot color
		% Desc: 	returns i-th colorant as spot color
		%----------------------------------------------------------------------------
		/get_ink_as_spot
		{
			dup /indexInk xd
			dup color exch get		% get i-th colorant tint
			exch names exch get		% get i-th colorant name
			[											% start array of alternativeColor values
				1.0 num 1 sub {0} repeat num indexInk roll		% set i-th ink to 1.0, the rest to 0.0
				ColorSpace 3 get exec								% execute tint conversion proc to convert i-th ink to alt color space
			]
			ColorSpace 2 get											% get alternative space
			create_spot_color											% create spot color
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_devicen_colorspace
% Stack: 	[names] [ alternativeColor1 ] ... [alternativeColorN ]  alternativeSpace N --> create_devicen_colorspace -- > colorspace
%				N - number of color components in DeviceN color
%				alternativeSpace - alternative color space to define DeviceN in
%				alternativeColori - alternative color values for i-th DeviceN colorant
%				names - colorant names
% Desc: 	creates DeviceN colorspace
%----------------------------------------------------------------------------
/create_devicen_colorspace
{
  /numColorants xd
  load /alternativeSpace xd
  bind /tintTransform exch def
  /names xd

  [ /DeviceN names alternativeSpace /tintTransform load ]
} bd

%----------------------------------------------------------------------------
% Proc:	create_devicen_color
% Stack: 	C1...CN DeviceNColorspace --> create_devicen_color -- >colorspec or
%				C1...CN [names] [ alternativeColor1 ] ... [alternativeColorN ]  alternativeSpace N --> create_devicen_color -- >colorspec
%				C1..CN - DeviceN color components values
%				DeviceNColorspace - DeviceN colorspace array
% Desc: 	creates DeviceN colorspec. Either uses DeviceN colorspace on stack ot creates new colorspace
%				from stack parameters
%----------------------------------------------------------------------------
/create_devicen_color
{
  DevicenColorSpec 9 dict copy
  begin
    dup type /arraytype ne
    {
      create_devicen_colorspace				% create DeviceN colorspace from stack parameters
    } if
    /ColorSpace xd										% CSA or device colorspace array
    /num ColorSpace 1 get length def	% number of color components/names
    /names ColorSpace 1 get def				% color components names
    num array astore /color xd				% color component values
  currentdict end
} bd

%----------------------------------------------------------------------------
% Registratin color dictionary definition
% registration color separates to all plates
%----------------------------------------------------------------------------
/RegistrationColorSpec
  ColorSpec 9 dict copy
  begin
    /num 1 def										% number of color components/names
 		/ColorModel	/Registration def	% color model
    /ColorSpace										% CSA or device colorspace array
    {
      [ /Separation /All DocCmykSpace { dup dup dup } ]
    } def
    /names [/All] def							% color components names

			%----------------------------------------------------------------------------
		% Stack: 	--> set_color -->
		% Desc: 	sets color as current
		%----------------------------------------------------------------------------
		/set_color
		{
			ColorSeparationLevel1
			{
				% paint in gray on all plates
				DocGrayScaleSpace safe_setcolorspace
				color aload pop 1 exch sub setcolor
			}
			{
				ColorSpace safe_setcolorspace
				color aload pop setcolor
			}
			ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			SeparateInColor
			{
				convert_to_cmyk true
			}
			{
				color aload pop 1 exch sub create_grayscale_color true
			} ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			color aload pop dup dup dup create_cmyk_color
		} bd
	currentdict end
def


%----------------------------------------------------------------------------
% Proc:		create_registration_color
% Stack: 	tint --> create_registration_color -- >colorspec
%					tint - tint of registration colorant
% Desc: 	registration color is a color that will separate to all plates
%					for composite output tint will appear in all channel, including spot and DeviceN
%----------------------------------------------------------------------------
/create_registration_color
{
  RegistrationColorSpec 9 dict copy
  begin
    1 array astore /color xd	% color component values
  currentdict end
} bd

%----------------------------------------------------------------------------
% LAB color dictionary definition
%----------------------------------------------------------------------------
/LabColorSpec
	ColorSpec 9 dict copy
  begin
    /names {/L /a /b} def			% color components names
    /num 3 def						% number of color components/names
	/ColorModel	/Lab def			% color model
    /ColorSpace DocLabSpace def		% LAB CSA

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			convert_to_cmyk /separate_color dexec
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			0 0 0 0 create_cmyk_color
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_lab_color
% Stack: 	L a b --> create_lab_color -- >colorspec
%			L, a, b - L, a, b color components respectively
%			colorspec - colorspec dicitonary
% Desc: 	creates LAB color dictionary
%----------------------------------------------------------------------------
/create_lab_color
{
	LabColorSpec 9 dict copy
	begin
		3 array astore /color exch def		% color component values
		/ColorSpace DocLabSpace def			% LAB color space 	
	currentdict end
} bd

%----------------------------------------------------------------------------
% Proc:		set_solid_fill
% Stack: 	colorspec --> set_solid_fill -->
%					colorspec - color of the fill
% Desc: 	sets fill color and fill type to solid
%----------------------------------------------------------------------------
/set_solid_fill
{
  /FillColor xd
	/$fil 0 def
} bd

%----------------------------------------------------------------------------
% Proc:		set_outline
% Stack: 	colorspec --> set_outline -->
%					colorspec - color of the outline
% Desc: 	sets outline color
%----------------------------------------------------------------------------
/set_outline
{
  /OutlineColor xd
} bd

%----------------------------------------------------------------------------
% Proc:   CheckLevelCompatibility
% Stack:  - CheckLevelCompatibility -
% Desc:   check the PostScript level of the interpeter/device against the
%         the PostScript level of the document we outputed, if not compatable
%         print error message and exit smoothly.
%----------------------------------------------------------------------------
/CheckLevelCompatibility
{
  /DocPsLevel where           	% make sure that Document level is defined
  {
    pop
    DocPsLevel get_ps_level gt  % if document level (LV) is 2 or more and the
    {                         	% device is not 2 or more
      @np                     	% newpath
      /Courier findfont 12    	% set a font
      scalefont setfont
      72 144 m                	% moveto 2 inch off the bottom of the page
      (The PostScript level of Corel document is higher than the PostScript) show
      72 132 m
      (level of this device. Change the PS Level in the Corel application) show
      72 120 m
      (by selecting the PostScript tab in the print dialog, and selecting) show
      72 108 m
      (document level from the Compatibility drop down list.) show
      flush
      spg
      quit
    } if
  } if
} bd

%----------------------------------------------------------------------------
% These two functions serve as a hook for PIPELINE ASSOCIATES INC..
% They have implemented a Corel dictionary in their interpreter. It
% performs mostly exotic fill rendering in .C code (instead of our
% PS code). The key here is to make sure their dictionary is above ours
% on the dictionary stack!!
%
% Notes: The first function should be called at the beginning of the script
%        AFTER our dictionary has been put pushed.
%        The second function should be called at the end of the script
%        BEFORE our dictionary is popped.
%
% Contact: Stephen Kochan (President)  (973)428-1700
%          Tim Demarest (Developer)
%
% New in Draw 8: A similar hook for Lexmark printers. They have also
%                implemented direct support for our fountain fills.
%
%                The key difference between Lexmark and Pipeline's
%                hook is that an integer, 1, is pushed on the stack. This
%                represents a compatibility level for the Exotic Fill routines.
%                When Corel makes a new version of CorelDRAW, this number should
%                be incremented if changes were made to the fountain fill code
%                which would make it ncompatible with existing Lexmark printers.
%
%
%----------------------------------------------------------------------------
/@BeginSysCorelDict
{
 % Pipeline hook...
 systemdict /Corel30Dict known {systemdict /Corel30Dict get exec} if

 % Lexmark hook...
 systemdict /CorelLexDict known {1 systemdict /CorelLexDict get exec} if
} bd

/@EndSysCorelDict
{
 % Pipeline hook...
 systemdict /Corel30Dict known {end} if

 %Lexmark hook...
 /EndCorelLexDict where {pop EndCorelLexDict} if
} bd

%----------------------------------------------------------------------------
% Autoflatness for paths too complex to image.
% The next section is to avoid the limitcheck error of typesetters.
% The painting operators of PostScript are rewritten to increase
% flatness until either the object can be printed, or a flatness
% of 10 more than the initial flatness setting has been reached.
% In this case an error message is displayed and printing continues with
% the next object.
% The auto-flatness will be enabled only if the value of the "AutoFlatness"
% variable is true. The code to set this flag is output by the client app.
%----------------------------------------------------------------------------
/AutoFlatness where
{
 pop

 AutoFlatness
 {
	 %----------------------------------------------------------------------------
	 % @ifl Increase flatness			initial_flatness @ifl initial_flatness
	 %----------------------------------------------------------------------------
	 /@ifl
	 {
		dup currentflat
		exch sub 10 gt             	% Is current flatness increase > 10?
		{
		 ([Error: PathTooComplex; OffendingCommand: AnyPaintingOperator]\n)
		 print flush @np exit
		}
		{
		 currentflat 2 add setflat
		} ifelse
	 } bd

	 %----------------------------------------------------------------------------
	 % --- Then redefine fill, eofill, clip, eoclip, & stroke
	 %----------------------------------------------------------------------------
	 /@fill /fill ld
	 /fill
	 {
		currentflat
		{
		 {@fill} stopped
		 {@ifl}
		 {exit}
		 ifelse
		} bind loop
		setflat
	 } bd

	 /@eofill /eofill ld
	 /eofill
	 {
		currentflat
		{
		 {@eofill} stopped
		 {@ifl}
		 {exit}
		 ifelse
		} bind loop
		setflat
	 } bd

	 /@clip /clip ld
	 /clip
	 {
		currentflat
		{
		 {@clip} stopped
		 {@ifl}
		 {exit}
		 ifelse
		} bind loop
		setflat
	 } bd

	 /@eoclip /eoclip ld
	 /eoclip
	 {
		currentflat
		{
		 {@eoclip} stopped
		 {@ifl}
		 {exit}
		 ifelse
		} bind loop
		setflat
	 } bd

	 /@stroke /stroke ld
	 /stroke
	 {
		currentflat
		{
		 {@stroke} stopped
		 {@ifl}
		 {exit}
		 ifelse
		} bind loop
		setflat
	 } bd
	} if
} if

%----------------------------------------------------------------------------
% Proc:	@ssa
% Stack:	- @ssa -
% Desc:	turn strokeadjust on if we're using level 2
%----------------------------------------------------------------------------
/@ssa
  Level2
  {
    {true setstrokeadjust}
  }
  {
    {}
  } ifelse
bd

%----------------------------------------------------------------------------
/d /setdash ld               	% d  setdash     					array offset d -
/j /setlinejoin ld           	% j  set line join     		join j -
/J /setlinecap ld            	% J  set line cap       	cap J -
/M /setmiterlimit ld         	% M  set miter limit  		value M -
/w /setlinewidth ld          	% w  set line width    		width w -
/O {/FillOverprint xd} bd     % O  set overprint fill   flag O -
/R {/OutlineOverprint xd} bd  % R  set overprint stroke	flag R -
/W /eoclip ld          				% W  clip path          	- W -
/c /curveto ld               	% c  curveto smooth    		x1 y1 x2 y2 x3 y3 c -
/C /c ld                     	% C  curveto corner    		x1 y1 x2 y2 x3 y3 C -
/l /lineto ld                	% l  lineto smooth     		x y l -
/L /l ld                     	% L  lineto corner     		x y L -
/rl /rlineto ld              	% rl rlineto     					x y rl -
/m /moveto ld                	% m  moveto      					x y m -
/n /newpath ld               	% n  newpath     					- n -
/N /newpath ld               	% N  newpath     					- N -
/P {11 rp} bd                	% P  pattern stroke    		(same as p)
/u {} bd                     	% u  begin group        	- u -
/U {} bd                     	% U  end group          	- U -
/A {pop} bd                  	% A  locked object     		flag A -
/q /@gs ld                   	% q  gsave        				- g -
/Q /@gr ld                   	% Q  grestore     				- Q -
/& {}bd                      	% &  pattern marker    		- & -
/@j {@sv @np} bd             	% StartArrowhead
/@J {@rs} bd                 	% EndArrowhead

%----------------------------------------------------------------------------
% Proc: 	g
% Stack:	gray g -
% Desc:		set gray color for solid fill
%----------------------------------------------------------------------------
/g
{
 1 exch sub           				% get black component
 0 0 0 4 roll 3
 create_cmyk_color set_solid_fill
 /$fil 0 def       						% set name (null), fill type
} bd

%----------------------------------------------------------------------------
% Proc:		G
% Stack:	gray G -
% Desc:		set gray outline color
%----------------------------------------------------------------------------
/G
{
 1 sub neg            				% get black component
 0 0 0 4 -1 roll
 create_cmyk_color set_outline
} bd

%----------------------------------------------------------------------------
% Proc: 	i
% Stack: 	flatness i -
% Desc: 	Sets the current flatness
%----------------------------------------------------------------------------
/i
{
 dup 0 ne
 {setflat}
 {pop}
 ifelse
} bd

%----------------------------------------------------------------------------
% Curveto procedures
%----------------------------------------------------------------------------
/v                           	% v		curveto smooth    	x12 y12 x3 y3 v -
{
 4 -2 roll                   	% get x12 y12 on top
 2 copy                      	% duplicate them
 6 -2 roll c                 	% move x3 y3 back to the end
} bd

/V /v ld                     	% V   curveto corner    	x12 y12 x3 y3 V -
/y {2 copy c} bd             	% y   curveto smooth    	x1 y1 x23 y23 y -
/Y /y ld                     	% Y   curveto corner    	x1 y1 x23 y23 Y -

%----------------------------------------------------------------------------
% Proc: 	@w
% Stack: 	[matrix] bscale width height angle @w -
% Desc:		set pen matrix "$ptm" to desired settings
% 				bscale is a flag:
%					0: no scale
%					1: scale with object using matrix supplied on the stack
% 				matrix is passed only if bscale is 1 (object total matrix)
%----------------------------------------------------------------------------
/@w
{
 matrix rotate /$ptm xd      	% define $ptm to be rotation matrix
 matrix scale                	% set pen shape
 $ptm dup concatmatrix
 /$ptm xd
 1 eq                        	% if scale, concat object matrix
 {
  $ptm exch dup concatmatrix
  /$ptm xd
 }if
 
 /patternScallingMatrix where	% apply pattern scaling matrix, if exists, to account for line width scaling in patterns
 {
	pop
	patternScallingMatrix $ptm matrix concatmatrix
	/$ptm xd
 }if
 
 1 w                         	% basic thickness to be transformed by $ptm
} bd

%----------------------------------------------------------------------------
% Proc: 	@g
% Stack: 	freq ang spotproc 1 @g -
%							--or--
%					0 @g - 		(use default)
% Desc:		Set halftone screen for gray filling
% 				spotproc is a spot procedure name (ex: /@dot or /@lin)
%----------------------------------------------------------------------------
/@g
{
 1 eq dup /$sdf xd           	% set global flag
 {                           	% next 3 parameters are set only if parm1 is 1
  /$scp xd                   	% Current spot func for fill
  /$sca xd                   	% Current screen angle for fill
  /$scf xd                   	% Current screen frequency for fill
 } if
} bd

%----------------------------------------------------------------------------
% Proc: 	@G
% Stack: 	freq ang spotproc 1 @G -
%								--or--
%					0 @G - 		(use default)
% Desc:		Set halftone screen for gray stroking
% 				spotproc is a spot procedure name (ex: /@dot or /@lin)
%----------------------------------------------------------------------------
/@G
{
 1 eq dup /$SDF xd           	% set global flag
 {                           	% next 3 parameters are set only if parm1 is 1
  /$SCP xd                   	% Current spot func for stroke
  /$SCA xd                   	% Current screen angle for stroke
  /$SCF xd                   	% Current screen frequency for stroke
 } if
} bd

%----------------------------------------------------------------------------
% Proc: 	@D
% Stack: 	freq ang spotproc @D -
% Desc: 	setscreen for all document
%----------------------------------------------------------------------------
/@D
{
 2 index 0 eq
 {
  $dsf 3 1 roll              	% frequency angle proc deffreq
  4 -1 roll pop
 } if
 3 copy
 exch $Scra add exch load    	%: frequency angle+$Scra {proc}
 SetScr
 /$dsp xd                    	% default spot func name
 /$dsa xd                    	% default screen angle
 /$dsf xd                    	% default screen frequency function
} bd

%----------------------------------------------------------------------------
% Proc: 	$ngx
% Stack:
% Desc: 	set screen function
%----------------------------------------------------------------------------
/$ngx
{
 $SDF
 {
  $SCF
  SeparationMode /Composite eq    % Check if not performing color seps.
  {$SCA}
  {$dsa}
  ifelse
  $SCP
  @ss
 }if      												% alt. screen? (determined by stroke attribs)
} bd

%----------------------------------------------------------------------------
% Proc: 	min
% Stack: 	val1 val2 --> min --> value
% Desc: 	minimum
%----------------------------------------------------------------------------
/min
{
 2 copy le
 {pop}
 {exch pop} ifelse           	% get minimum of both values
} bd

%----------------------------------------------------------------------------
% Proc: 	max
% Stack: 	val1 val2 --> max --> value
% Desc: 	maximum
%----------------------------------------------------------------------------
/max
{
 2 copy ge
 {pop}
 {exch pop}
 ifelse  						         	% get max of both values
} bd

%----------------------------------------------------------------------------
% Proc: 	in_range
% Stack: 	value minimum maximum --> in_range --> newvalue
% Desc: 	forces a value between two limits
%----------------------------------------------------------------------------
/in_range
{
  3 -1 roll                   % get value on top
  min max
} bd

%----------------------------------------------------------------------------
% Proc: 	InRange
% Stack: 	value minimum maximum --> in_range --> newvalue
% Desc: 	The same as in_range, legacy namy for use in PS fills
%----------------------------------------------------------------------------
/InRange /in_range load bd

%----------------------------------------------------------------------------
% Proc:	@sqr
% Stack: 	size @sqr -
% Desc:
%----------------------------------------------------------------------------
/@sqr
{
 dup 0 rl
 dup 0 exch rl
 neg 0 rl
 @cp
} bd

%----------------------------------------------------------------------------
% Proc:		currentscale
% Stack: 	- currentscale sx sy
% Desc:
%----------------------------------------------------------------------------
/currentscale
{
 1 0 dtransform
 matrix defaultmatrix idtransform
 dup mul exch dup mul add sqrt

 0 1 dtransform
 matrix defaultmatrix idtransform
 dup mul exch dup mul add sqrt

} bd

%----------------------------------------------------------------------------
% Proc:		@unscale
% Stack: 	- unscale -
% Desc:
%----------------------------------------------------------------------------
/@unscale
{
 %stub... currentscale 1 exch div exch 1 exch div exch scale
} bd

%----------------------------------------------------------------------------
% Proc: 	wDstChck
% Stack:
% Desc: 	NEEDED by functions in USERPROC.TXT
%----------------------------------------------------------------------------
/wDstChck
{
 2 1 roll dup 3 -1 roll
 eq {1 add} if
} bd

%----------------------------------------------------------------------------
% Proc: 	@dot
% Stack: 	x y @dot num
% Desc:		implementation of a dot spot function for halftoning(see setscreen)
%----------------------------------------------------------------------------
/@dot
{
 dup mul exch dup mul add
 1 exch sub
} bd

%----------------------------------------------------------------------------
% Proc: 	@lin
% Stack: 	x y @lin num
% Desc:		implementation of a line spot function for halftoning(see setscreen)
%----------------------------------------------------------------------------
/@lin
{
 exch pop abs 1 exch sub
} bd

%----------------------------------------------------------------------------
% Proc: 	cmyk2rgb
% Stack: 	c m y k cmyk2rgb r g b
% Desc: 	converts cmyk to rgb using standard algorithm
%----------------------------------------------------------------------------
/cmyk2rgb
{                            	% c m y k
 3
 {
  dup 5 -1 roll             	% m y k k c
  add                       	% m y k k+c
  1 exch sub                	% m y k 1-(k+c)         % r = 1-(k+c)
  dup 0 lt                  	% m y k r r<0
  {
   pop 0                    	% m y k 0               % 0 < r < 1
  } if
  exch                      	% m y r k
 } repeat                   	% r g b k               % for each color
 pop                        	% r g b
} bd

%----------------------------------------------------------------------------
% Proc: 	rgb2cmyk
% Stack: 	r g b rgb2cmyk c m y k
% Desc: 	converts rgb to cmyk using standard algorithm
%----------------------------------------------------------------------------
/rgb2cmyk
{                            	% r g b
 3
 {                           	% r g b
  1 exch sub                 	% r g 1-b       				% y = 1 - b
  3 1 roll                   	% y r g
 } repeat                    	% c m y
 3 copy                      	% c m y c m y
 min min                     	% c m y min(c,m,y)     	% K=min(c,m,y)
 3
 {                           	% c m y K
  dup 5 -1 roll              	% m y K K c
  sub neg                    	% m y K c-K     				% C = c - K
  exch                       	% m y C K
 } repeat                    	% C M Y K
} bd

%----------------------------------------------------------------------------
% Proc: 	rgb2g
% Stack:
% Desc: 	converts rgb to gray using standard algorithm
%----------------------------------------------------------------------------
/rgb2g
{
 2 index .299 mul            	% r g b .299r
 2 index .587 mul add        	% r g b .299r+.587g
 1 index .114 mul add        	% r g b .299r+.587g+.144b
 4 1 roll                    	% gray r g b
 pop pop pop                 	% gray
} bd

%----------------------------------------------------------------------------
% WaldoColor might already be defined if this is an EPS file
%----------------------------------------------------------------------------
/WaldoColor_5 where
{
 pop
}
{
  %----------------------------------------------------------------------------
  % store pointers to actual color operators
  %----------------------------------------------------------------------------
  /CorelImage systemdict /image get def
  /CorelSetGray systemdict /setgray get def
  /CorelGetGray systemdict /currentgray get def
  /CorelSetTransfer systemdict /settransfer get def
  /CorelGetTransfer systemdict /currenttransfer get def

  /SetRgb /setrgbcolor ld
  /GetRgb /currentrgbcolor ld
  /SetGry /setgray ld
  /GetGry /currentgray ld
  /SetRgb2 systemdict /setrgbcolor get def
  /GetRgb2 systemdict /currentrgbcolor get def
  /SetHsb systemdict /sethsbcolor get def
  /GetHsb systemdict /currenthsbcolor get def

  %----------------------------------------------------------------------------
  % Proc: 	rgb2hsb
  % Stack:
  % Desc: 	converts rgb to hsb
  %----------------------------------------------------------------------------
  /rgb2hsb
  {
   SetRgb2
   GetHsb
  } bd

  %----------------------------------------------------------------------------
  % Proc: 	hsb2rgb
  % Stack:
  % Desc: 	converts hsb to rgb
  %----------------------------------------------------------------------------
  /hsb2rgb
  {                            	% h s b
   3 -1 roll                   	% s b h
   dup floor sub               	% s b H         			% ensure 0 < H < 1
   3 1 roll                    	% H s b
   SetHsb
   GetRgb2
  } bd

  %----------------------------------------------------------------------------
  % define the setcmykcolor operator if not already defined
  % if it is already defined, we want to store it away so that when we later
  % superclass this operator to our own in order to separate eps files, we can
  % access the existing call.  If it does not exist, it will be emulated with
  % the corresponding rgb calls.
  %----------------------------------------------------------------------------
  /setcmykcolor where
  {
    pop
    /LumSepsDict where              % check if Luminus TrapWise Separation dictionary is defined
    {
      pop
      /SetCmyk_5
      {
        LumSepsDict                 % get setcmykcolor from their dict and run it
        /setcmykcolor get exec
      } def
    }
    {
      /AldusSepsDict where
      {
        pop
        /SetCmyk_5
        {
          AldusSepsDict             % get setcmykcolor from their dict and run it
          /setcmykcolor get exec
        } def
      }
      {
        /SetCmyk_5 /setcmykcolor ld
      } ifelse
    } ifelse
  }
  {
	%----------------------------------------------------------------------------
	/setcmykcolor
	{
	create_cmyk_color /separate_set_color dexec
	/$ffpnt xd		% painting flag
	} bd

    /SetCmyk_5                      % cyan magenta yellow black setcmykcolor -
    {
      cmyk2rgb
      SetRgb
    } bd
  } ifelse

  %----------------------------------------------------------------------------
  /currentcmykcolor where
  {
   pop
   /GetCmyk
   /currentcmykcolor ld
  }
  {
   /GetCmyk
   {
    GetRgb
    rgb2cmyk
   } bd
  } ifelse

  %----------------------------------------------------------------------------
  % define the setoverprint operator if not already defined
  % NOTE: We do not want to redefine this operator if it is defined so that
  %       other apps can separate our EPS files.
  %----------------------------------------------------------------------------
  /setoverprint where
  {pop}
  {
   /setoverprint               	% boolean setoverprint
   {
    /CurrentOverprint xd
   } bd
  } ifelse

  %----------------------------------------------------------------------------
  % define the currentoverprint operator if not already defined
  % NOTE: We do not want to redefine this operator if it is defined so that
  %       other apps can separate our EPS files.
  %----------------------------------------------------------------------------
  /currentoverprint where
  {pop}
  {
   /currentoverprint           	% currentoverprint boolean
   {
		CurrentOverprint
   } bd
  } ifelse

  %----------------------------------------------------------------------------
  % proc : ColorImage
  %
  % Stack: width height #bits matrix dataaq1 ... dataaqN multi
  %        #colors ColorImage -
  %        where:
  %          dataaqI: Data aquisition function I ( we can have 1, 3 or 4 of them)
  %          multi  : Boolean, true means multi-stram image, false means single stram image
  %
  % Desc : Defines the ColorImage operator
  %				 if colorimage is define it uses the definition for our ColorImage,
  %        if not we will define our own.
  %
  %----------------------------------------------------------------------------
  /colorimage where
  {
   pop
   /ColorImage {colorimage} def	      % 8Dec94: rwm: this used to be /colorimage load def
                                      % it was changed to support colorimage separation
  }
  {
   /ColorImage
   {
     /ncolors xd			                % # of colors
     /$multi xd                       % multi-stream colorimage
     $multi true eq
     {                                % multi-stream colorimage, pop all the image data
       ncolors 3 eq
       {                              % RGB image
         /daqB xd
         /daqG xd
         /daqR xd
         pop pop exch pop abs         % pop the stack leave the # of lines
         {
           daqR pop                   % pop the Red line
           daqG pop                   % pop the Green line
           daqB pop                   % pop the Blue line
         } repeat
       }
       {                              % CMYK image
         /daqK xd
         /daqY xd
         /daqM xd
         /daqC xd
         pop pop exch pop abs         % pop the stack leave the # of lines
         {
           daqC pop                   % pop the Cyan line
           daqM pop                   % pop the Magenta line
           daqY pop                   % pop the Yellow line
           daqK pop                   % pop the Black line
         } repeat
       } ifelse
     }
     {                                % single-stream colroimage
       /dataaq xd
       {
         dataaq
         ncolors dup 3 eq
         {
           /$dat xd
           0 1 $dat length
           3 div 1 sub
           {
             dup 3 mul
             $dat 1 index get
             255 div
             $dat 2 index 1 add get
             255 div
             $dat 3 index 2 add get
             255 div
             rgb2g 255 mul
             cvi exch pop
             $dat 3 1 roll put
           } for
           $dat 0 $dat length 3
           idiv getinterval pop
         }
         {
           4 eq
           {
             /$dat xd
             0 1 $dat length
             4 div 1 sub
             {
               dup 4 mul
               $dat 1 index get
               255 div
               $dat 2 index 1 add get
               255 div
               $dat 3 index 2 add get
               255 div
               $dat 4 index 3 add get
               255 div
               cmyk2rgb rgb2g 255 mul
               cvi exch pop
               $dat 3 1 roll put
             } for
             $dat 0 $dat length
             ncolors idiv
             getinterval
           } if
         } ifelse
       }
       image
     } ifelse
   } bd
  } ifelse

  %----------------------------------------------------------------------------
  /currentcmykcolor
  {
    GetCmyk
  } bd

  %----------------------------------------------------------------------------
  /sethsbcolor
  {
   hsb2rgb
   setrgbcolor
  } bd

  %----------------------------------------------------------------------------
  /currenthsbcolor
  {
   currentrgbcolor
   rgb2hsb
  } bd

  %----------------------------------------------------------------------------
  /setgray
  {
   dup dup
   setrgbcolor
  } bd

  %----------------------------------------------------------------------------
  /currentgray
  {
   currentrgbcolor             	% r g b
   rgb2g
  } bd

  %----------------------------------------------------------------------------
  % Proc:   InsideDCS
  % Desc:   defines the flag InsideDCS file to false, will be set just prior to
  %         outputing a DCS file and reset after that.
  %----------------------------------------------------------------------------
  /InsideDCS false def

  %----------------------------------------------------------------------------
  % Proc: 	IMAGE
  % Stack: 	- IMAGE -
  % Desc: 	load the defined image operater and redefine it into IMAGE
  %----------------------------------------------------------------------------
  /IMAGE /image ld

  %----------------------------------------------------------------------------
  % Proc:   image
  % Stack:  width height bits matrix datasrc image -
  %         dict image -
  % Desc: 	this proc redefine the systemdic image proc. It will either call
  %         the IMAGE if we do not need to do anything to the image, or it
  %         pop all the image data if the image need not to print.
  %----------------------------------------------------------------------------
  /image                            % Redefine image proc
  {
    InsideDCS                       % check if the image is inside a DCS file
    {
      IMAGE                         % play the image
    }
    {
    /EPSDict where                  % check if an EPS dictionary on the stack
    {                               % Inside EPS file
      pop                           % pop dictinary

      SeparationMode /Composite eq
      {                             % composite
        IMAGE                       % use the systemdict image call
      }
      {                             % separation
        dup type /dicttype eq       % check if there is a dictionary on the stack
        {                           % There is a dict, this must ba a LEVEL 2 or 3 IMAGE call,
          dup /ImageType get 1 ne
          {                         % level 3 image dictionary
            IMAGE                   % use the systemdict image call
          }
          {                         % Level 2 image dictionary
            dup dup
            /BitsPerComponent
            get 8 eq exch
            /BitsPerComponent
            get 1 eq or
            currentcolorspace 0 get
            DocGrayScaleSpace eq
            and
            {                       % It is a GrayScale or a Mono image
              SeparationPlateName
              (Black) eq
              {                     % Black plate
                IMAGE               % play the image, use the systemdict image call
              }
              {                     % Not a black plate
                dup /DataSource get
                /TCC xd             % get datasource proc from dictionary and save it
                /Height get abs     % get number of lines
                { TCC pop } repeat  % pop all the image lines
              } ifelse
            }
            {                       % It is not a gray scale image
              IMAGE                 % output the image
            } ifelse
          } ifelse
        }
        {                           % this is a LEVEL 1 IMAGE call
          2 index 1 ne              % get number of bits/sample
          {                         % 8 bits, gray image
            SeparationPlateName
            (Black) eq
            {                       % Black plate
              IMAGE                 % use the systemdict image call
            }
            {                       % Not a black plate
              /TCC xd               % save the datasource proc
              pop pop exch pop abs  % pop image parameters, leaving the number of lines only
              { TCC pop } repeat    % pop all the image lines
            } ifelse
          }
          {                         % 1 bit
            IMAGE                   % use the systemdict image call
          } ifelse
        } ifelse
      } ifelse
    }
    {                               % not in an EPS file
      IMAGE                         % use the systemdict image call
    } ifelse                        %
    } ifelse                        % InsideDCS
  } bd
} ifelse

%----------------------------------------------------------------------------
% Desc: 	sets the fill mode to EVEN_ODD mode.
%----------------------------------------------------------------------------
/$fm 0 def

%----------------------------------------------------------------------------
% Proc: 	wfill
% Stack: 	wfill
% Desc: 	sets the type of fill to use (fill or eofill)
%         depending on the fill mode (winding or even-odd).
%----------------------------------------------------------------------------
/wfill
{
 1 $fm eq					           	% fillmode
 {
  fill												% normal non-zero winding number rule
 }
 {
  eofill											% even-odd rule
 } ifelse
} bd

%----------------------------------------------------------------------------
% Proc: 	@Pf
% Stack: 	- @Pf -
% Desc: 	Postscript Fill
% 				Call user-defined Postscript fill with current parameters
% 				20dec90:MB: Print PS fill only in composite
%           or in black plane of color seps.
% NOTE: All PS fills expect the current UNIT to be MIL (1/1000 inch)
% and Bburx, .. need to be specified in that unit as well.
%----------------------------------------------------------------------------
/@Pf
{
 @sv
 SeparationMode /Composite eq	% Composite or...
 {
  true
 }
 {
  $Psc 0 ne or	 								% Color PS fill or..
  $ink_5 3 eq or
 }ifelse
 								% Black separation
 {                           	% PS fills can be printed
  0 J 0 j [] 0 d             	% reset stroke attributes (all PS fills set line width)
  FillOverprint safe_setoverprint
  FillColor /separate_set_color dexec pop
  $ctm setmatrix             	% reset matrix for PS-filling
  72 1000 div dup
  matrix scale               	% scaling matrix
  dup concat                 	% change current ctm
  dup Bburx exch Bbury exch
  itransform
  ceiling cvi /Bbury xd
  ceiling cvi /Bburx xd      	% change unit of BBox
  Bbllx exch Bblly exch
  itransform
  floor cvi /Bblly xd
  floor cvi /Bbllx xd
  $Prm aload pop             	% Bring the parameters on stack
  $Psn load exec             	% execute the ps fill as desired
 }
 {                           	% Not proper color plane, fill in white instead.
  1 SetGry wfill
 } ifelse
 @rs                         	% restore original state
 @np                         	% and clear the path
} bd

%----------------------------------------------------------------------------
% Proc: 	F
% Stack: 	- F -
% Desc: 	fill path
%----------------------------------------------------------------------------
/F
{
	matrix currentmatrix        					% save current transfo matrix on stack
	$sdf
	{
	$scf $sca $scp @ss
	} if                        					% alternate halftone screen?

	FillOverprint safe_setoverprint

	$fil 1 eq

	{CorelPtrnDoFill}            					% pattern fill
	{
		$fil 2 eq                  					% fountain fill?
		{gradient_fill}                      					% fountain fill path
		{
			$fil 3 eq                 				% Postscript fill?
			{@Pf}                     				% PS fill
			{
				get_simulate_devicen FillColor /ColorModel get /DeviceN eq and
				{
					% simulate DeviceN color on Level 2
					% oveprint N objects with individual DeviceN inks
        	0 1 FillColor /num get 1 sub		% iterate through all DeviceN plates
        	{
          		dup 0 gt											% if not the first plate, overprint it
          		{
            			true safe_setoverprint
          		}if

          		FillColor /get_ink_as_spot dexec	% get DeviceN i-th ink as spot color

          		/set_color	dexec									%	set DeviceN i-th ink as current color

          		@gs
          		wfill															% paint the fill
          		@gr

        	} for
      	}
      	{
        	FillColor /separate_set_color dexec
        	{wfill}
        	{@np} ifelse
      	} ifelse
   } ifelse
  } ifelse
 } ifelse
 $sdf
 {
  $dsf $dsa $dsp @ss
 } if                        				% reset default halftone screen
 setmatrix                   				% reset original transfo matrix on stack
} bd

%----------------------------------------------------------------------------
% Proc: 	f
% Stack: 	- f -
% Desc: 	closepath fill
%----------------------------------------------------------------------------
/f
{
 @cp F
} bd


%----------------------------------------------------------------------------
% Proc: 	S
% Stack: 	- S -
% Desc: 	stroke
%----------------------------------------------------------------------------
/S
{
  matrix currentmatrix        	% save current transfo matrix on stack
  $ctm setmatrix              	% reset normal ctm
  $SDF {$SCF $SCA $SCP @ss}if 	% alternate halftone screen?

  OutlineOverprint safe_setoverprint

  get_simulate_devicen OutlineColor /ColorModel get /DeviceN eq and
	{
		% simulate DeviceN color on Level 2
		% oveprint N objects with individual DeviceN inks

    0 1 OutlineColor /num get 1 sub		% iterate through all DeviceN plates
    {
      dup 0 gt												% if not the first plate, overprint it
      {
        true safe_setoverprint
      }if

      OutlineColor /get_ink_as_spot dexec	% get DeviceN i-th ink as spot color

      /set_color	dexec										%	set DeviceN i-th ink as current color

			matrix currentmatrix
			$ptm concat													% set the pen matrix
			@gs
			stroke
			@gr
			setmatrix														% reset the original matrix(from stack)

    } for
  }
  {
    OutlineColor /separate_set_color dexec
    {
      matrix currentmatrix
      $ptm concat              	% set the pen matrix
      stroke
      setmatrix                	% reset the original matrix(from stack)
    }
    {@np}ifelse
  } ifelse

 $SDF {$dsf $dsa $dsp @ss}if		% reset default halftone screen
 setmatrix                   		% reset original matrix set on stack
} bd

%----------------------------------------------------------------------------
% Proc: 	s
% Stack: 	- s -
% Desc: 	closepath stroke
%----------------------------------------------------------------------------
/s
{
 @cp
 S
} bd

%----------------------------------------------------------------------------
% Proc: 	B
% Stack: 	- B -
% Desc: 	fill, then stroke
%----------------------------------------------------------------------------
/B
{
 @gs F @gr                   	% fill, then
 S                           	% stroke
} bd

%----------------------------------------------------------------------------
% Proc: 	b
% Stack: 	- b -
% Desc: 	closepath, fill, stroke
%----------------------------------------------------------------------------
/b
{
 @cp B
} bd

%----------------------------------------------------------------------------
% Proc: 	E
% Stack: 	name llx lly urx ury description E -
% Desc:		define pattern
% 				a pattern will be defined as an array of 5 entries:
% 				(0)llx (1)lly (2)urx (3)ury (4)descrition
% 				the description is also an array of executable strings
%----------------------------------------------------------------------------
/_E
{
 5 array astore    						% parms are in an array
 exch cvlit xd			      		% defined with key equal to the name(string)
} bd

%----------------------------------------------------------------------------
% Proc: 	@cc
% Stack: 	- @cc string
% Desc: 	collect bitmap data from currentfile (input)
%----------------------------------------------------------------------------
/@cc
{
 currentfile $dat readhexstring pop
} bd

%----------------------------------------------------------------------------
% Proc: 	@sm
% Stack: 	- @sm -
% Desc: 	save current transfo matrix into global $ctm
%----------------------------------------------------------------------------
/@sm
{
 /$ctm $ctm currentmatrix def
} bd

%----------------------------------------------------------------------------
% Proc: 	@E
% Stack: 	bbllx bblly bburx bbury matrix @E -
% Desc: 	Define Object's bbox
% 				Must be called before painting if PATTERNS, PSFILLS, or
% 				FOUNTAINS are used
%----------------------------------------------------------------------------
/@E
{
  /Bbury xd /Bburx xd      		% upper rt. of object's bbox in absolute space
 /Bblly xd /Bbllx xd      		% lower lt. of object's bbox in absolute space
} bd

%----------------------------------------------------------------------------
% Proc: 	@c
% Stack:
% Desc: 	Close sub Path
%					Must be called during the path description
%----------------------------------------------------------------------------
/@c
{
 @cp
} bd

%----------------------------------------------------------------------------
% Proc: 	@P
% Stack: 	parm1 .. parmn n nColor fillname @P -
% Desc: 	PostScript fill
%----------------------------------------------------------------------------
/@P
{       											% COREL Postscript fill # of parms can vary
 /$fil 3 def        					% set global for filling
 /$Psn xd     								% PS-fill name
 /$Psc xd											% 0 - black only, 1 - color
 array astore      						% build array for PS-fill parms
 /$Prm xd     								% parms in Prm
} bd

%----------------------------------------------------------------------------
% Proc: 	tcc
% Stack: 	- tcc -
% Desc:
%----------------------------------------------------------------------------
/tcc {@cc} def 								% no bind def because @cc redefn'

%----------------------------------------------------------------------------
% Proc:		@B
% Stack: 	- @B
% Desc: 	stroke, then fill
%----------------------------------------------------------------------------
/@B
{
 @gs S   @gr         					% stroke
 F              							% fill
} bd

%----------------------------------------------------------------------------
% Proc:		@b
% Stack: 	- @b -
% Desc: 	closepath, stroke & fill path
%----------------------------------------------------------------------------
/@b
{
 @cp @B
} bd

%----------------------------------------------------------------------------
% Proc:		init_separation
% Stack: 	--> init_separation -->
% Desc: 	initialize global color separation parameters
%
%       	SeparationMode defines the current mode for color separation :
%						/Composite - no color separation
%           /OnHost - colors are separated in the application ( on host )
%           /InRip - colors are separated in the RIP
%
%       	SeparationPlateName - string defining the current color plane being
%  					printed.  The possible values are (case sensitive, not to be
%						translated); /Cyan, /Magenta, /Yellow, /Black or any spot color
%						defined in the document; e.g. (Pantone 345)
%
%					SeparationPlateIndex - index of separation plate, -1 - not defined,
%					0 - Cyan,	1 - Magenta, 2 - Yellow, 3 - Black, 4 - any spot
%
%----------------------------------------------------------------------------
/init_separation
{
	% inherit separation parameters from parent document if embedded as EPS
	/SeparationMode where
	{
		pop
	}
	{
		/SeparationMode /Composite def
	} ifelse


	/SeparationPlateName where
	{
		pop
	}
	{
		/SeparationPlateName null def
	} ifelse

	/SeparateInColor where
	{
		pop
	}
	{
		/SeparateInColor false def
	} ifelse

	SeparationMode /Composite eq
	{
		/SeparationPlateIndex -1 def
	}
	{
		/SeparationPlateIndex 4 def
	} ifelse

	/CmykPlates [ /Cyan /Magenta /Yellow /Black ] def

	0 1 3
	{
		dup
		CmykPlates exch get SeparationPlateName eq
		{
			/SeparationPlateIndex xd
			exit
		} if
		pop
	} for

	% init legacy separation parameters used for separation of pre-X5
	% generated embedded EPS documents

	/CurrentInkName_5 SeparationPlateName def

	/$ink_5 SeparationPlateIndex def

	SeparationMode /OnHost eq
	{
		/SepMode_5 2 def
	}
	{
		/SepMode_5 0 def
	} ifelse

	/SepsColor SeparateInColor def	
} bd

%----------------------------------------------------------------------------
% Proc:		init_separation_from_legacy
% Stack: 	- init_separation_from_legacy -
% Desc: 	inits separation from legacy pre-X5 separation parameters
%----------------------------------------------------------------------------
/init_separation_from_legacy
{
	EpsFile
	{
		/SepMode_5 where
		{
			pop
			SepMode_5 2 eq
			{
				/SeparationMode /OnHost def
			}
			{

				/SeparationMode /Composite def
			}
			ifelse
		} if
		
		/CurrentInkName_5 where
		{
			pop
			/SeparationPlateName CurrentInkName_5 def
		} if
		
		/$ink_5 where
		{	pop
			/SeparationPlateIndex $ink_5 def
		} if
		
		/SepsColor where
		{
			pop
			/SeparateInColor SepsColor def
		} if
	} if
} bd

init_separation_from_legacy

%----------------------------------------------------------------------------
% Proc:		@whi
% Stack: 	- @whi -
% Desc: 	Fill Page white
%----------------------------------------------------------------------------
/@whi
{
 @gs
 -72000 dup m
 -72000 72000 l
 72000 dup l
 72000 -72000 l
 @cp 1 SetGry fill
 @gr
} bd

%----------------------------------------------------------------------------
% Proc:		@neg
% Stack: 	- @neg -
% Desc: 	MAKE ALL COLORS NEGATIVE
% 				Only set the GRAY scale transfer function since WALDO only
% 				uses negative for color separations.
%----------------------------------------------------------------------------
/@neg
{  [{1 exch sub} /exec cvx currenttransfer /exec cvx] cvx settransfer
 @whi          								% fill page in white (Will be turned into white)
} bd

%----------------------------------------------------------------------------
% ------------------------- AX system --------------------------------------
%----------------------------------------------------------------------------
/deflevel 0 def								% global

%----------------------------------------------------------------------------
% Proc:		@sax
% Stack: 	- @sax -
% Desc: 	start an excution array
% NOTE:		an array should be started IMMEDITAELY AFTER @sax
%         each @sax requires a following @eax
%----------------------------------------------------------------------------
/@sax
{
  /deflevel deflevel 1 add def
} bd

%----------------------------------------------------------------------------
% Proc:		@eax
% Stack: 	[ex array] @eax -
%         or
%         [ ... [ex array] @eax [ ... [ex array] {ex array code}
% Desc: 	end and possibly execute an execution array
%         This will either load array execution code or execute the
%         array depending on the level (as set by @sax).
%         EACH @eax needs a preceding @sax
%----------------------------------------------------------------------------
/@eax
{
 % decrement deflevel but NEVER below 0.
 /deflevel deflevel dup 0 gt {1 sub} if def
 deflevel 0 gt
 {
  /eax load       						% push eax code onto stack for later execution
 }
 {
  eax       									% execute the array on the stack NOW
 }
 ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		eax
% Stack: 	[ex array] eax -
% Desc: 	execute an execution array
% NOTE:		This should only be called by @eax. DO NOT DIRECTLY
%         CALL THIS ROUTINE!
%----------------------------------------------------------------------------
/eax
{
 {exec} forall
} bd

%----------------------------------------------------------------------------
% Proc:		@rax
% Stack:
% Desc:
%----------------------------------------------------------------------------
/@rax
{
 deflevel 0 eq
 {
  @rs @sv
 }
 if
} bd

%----------------------------------------------------------------------------
% Proc:		pdfmark
% Stack: 	[ .... pdfmark
% Desc:
%----------------------------------------------------------------------------
systemdict /pdfmark known not
{
 /pdfmark /cleartomark ld
} if

%----------------------------------------------------------------------------
% Proc: 	wclip
% Stack: 	- wclip -
% Desc: 	sets the type of clipping to use (clip or eoclip)
%         depending on the clipping mode (winding or even-odd).
%----------------------------------------------------------------------------
/wclip
{
 1 $fm eq						% fillmode
 {
  clip							% normal non-zero winding number rule
 }
 {
  eoclip						% even-odd rule
 } ifelse
} bd
%----------------------------------------------------------------------------
% Raster images support
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
% Proc: 	set_image_clipping
% Stack: 	cropllx croplly cropurx cropury matrix --> set_image_clipping -->
% Desc: 	set clipping path for image
%----------------------------------------------------------------------------
/set_image_clipping
{
 concat      									% integrate transfo right away
 3 index 3 index m        		% set clipping path(cropping rect)
 3 index 1 index l
 2 copy l
 1 index 3 index l
 3 index 3 index l
 clip         								% this is the clipping path
 pop pop pop pop							% pop cropping rect
} bd

%----------------------------------------------------------------------------
% Proc: 	set_image_parameters
% Stack: 	pxlwid pxlhei bits llx lly urx ury background foreground
%         		 ---> set_image_parameters -->
% Desc: 	sets image parameters from stack
%----------------------------------------------------------------------------
/set_image_parameters
{
	/$frg xd /$bkg xd						% foreground/background flags
	/$ury xd /$urx xd
	/$lly xd /$llx xd          	% bitmap rectangle
	/$ncl xd           					% # of color components
	/$bts xd           					% # of bits per color component
	/$hei xd /$wid xd           % pixel size
} bd

%----------------------------------------------------------------------------
% Proc:		output_image
%
% Stack: 	pxlwid pxlhei bits bitplanes
%         		llx lly urx ury backgroundflag foregroundflag
%         		cropllx croplly cropurx cropury matrix
%        		dataproc --> output_image -->
%
% Desc: 	output bitmap image
%
% Parms:  pxlwid pxlhei 	size of bitmap in pixels
%         bits 				# of bits per sample
%         bitplanes  		# of color planes
%         llx lly urx ury 	total size of bitmap(before transfos)
%         backgroundflag
%						1: fill background with current fill,
%           0: transparent background (only for monochrome/grayscale bitmaps)
%         foregroundflag :
%						1: mask background with current stroke,
%           0: transparent background (only for monochrome/grayscale bitmaps)
%         cropllx croplly cropurx cropury: cropping rect (before transfos)
%         matrix 			 additional transfo matrix for stretching/rotating, etc..
%         dataproc :		data acquisition procedure
%
%       	Note:  pxlhei < 0 prints bitmap UPSIDE down
%
%----------------------------------------------------------------------------
/output_image
{
 /@cc xd											% store data aquisition procedure

	@sm @gs     								% save current ctm and graphics state
	set_image_clipping          % set CTM and clipping

	set_image_parameters				% store image parameters from stack

	SeparationMode /OnHost eq EpsFile and
	{
		separate_output_image
	}
	{
		output_composite_image
	} ifelse

	@gr $ctm setmatrix          % Restore graphics state & org matrix
} bd

%----------------------------------------------------------------------------
% Proc:		output_composite_image
% Stack: 	--> output_composite_image -->
% Desc: 		output bitmap image in composite mode
%----------------------------------------------------------------------------
/output_composite_image
{
	DocPsLevel 3 eq							% Using Level 3
	MaskedImage true eq	and
	{
		output_masked_image   		% call level 3 masked images code
	}
	{
	 $bts 1 gt              		% grayscale or color?
	 DocPsLevel 2 eq						% and using level 2 or 3?
	 DocPsLevel 3 eq or
	 and
	 {
		DevicenImage							% check if DeviceN image
		{
			output_devicen_image   	% output DeviceN image to Level2 and 3
		}
		{
			output_color_image			% call level 2 color bitmap code
		}ifelse
	 }
	 {													% level 1 or monochrome?
		$bts 1 eq    							% check for 1 bitplane (monochrome)
		{
		 output_monochrome_image
		}
		{
		 output_color_image_level1	% call level 1 bitmap code
		} ifelse
	 } ifelse
  } ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		separate_output_image
% Stack: 	--> separate_output_image -->
% Desc: 		separates image according to global separation parameters then outputs it
%----------------------------------------------------------------------------
/separate_output_image
{
	@gs
	$bts 1 gt
	{
		separate_output_color_image
	}
	{
		separate_output_monochrome_image
	} ifelse
	@gr

	not	% if not separated to current plate, check if we need to knock image out
	{
		currentoverprint not
		{
			% knock out image by painting white rectangle
			1.0 SetGry
			wfill
		} if
	} if

	@np
} bd

%----------------------------------------------------------------------------
% Stack: 	file --> set_decode_filter --> file
% Params:	file - current file object with installed filter chain on top
% Desc: 	installs image data decode filter on top of filter chain
%----------------------------------------------------------------------------
/set_decode_filter
{
	ImageCompression /JPEG eq				% JPEG compression
	{
		/DCTDecode filter
	}
	{
		ImageCompression /RLE eq			% RunLengthDecode filter
		{
			/RunLengthDecode filter
		}
		{
			ImageCompression /LZW eq		% LZWDecode filter
			{
				/LZWDecode filter
			}if
		} ifelse
	} ifelse
} bd

%----------------------------------------------------------------------------
% Proc: 	create_datasource
% Stack: 	--> create_datasource --> file
%	Params:	file - current file object with installed filter chain on top
% Desc: 	creates image datasource as current file with edecoding filters chain
%----------------------------------------------------------------------------
/create_datasource
{
	currentfile
	
	DevicenImage not get_ps_level 2 gt or
	{	/ASCII85Decode filter
	}if

	set_decode_filter
} bd

%----------------------------------------------------------------------------
% Proc: 		set_image_strip_parameters
% Stack: 	numPlanes stripRows --> set_image_strip_parameters  -->
% Params:	numPlanes - number of planes to output image strip to
%				stripRows - number of image rows in single strip
% Desc: 		sets parameters for outputing image strip
%----------------------------------------------------------------------------
/set_image_strip_parameters
{
	/stripRows xd
	/numPlanes xd

	/stripBuffer										% buffer for strip data
		$wid $bts
		mul $ncl mul
		stripRows mul
		8 div
		ceiling cvi
		dup 65535 gt
		{
			pop $ncl $bts mul 
		}if
		string

	def

	DevicenImage
	{
		/readstrip
		{
			DataSource stripBuffer readhexstring pop
		} bd
	}
	{
		/readstrip
		{
			DataSource stripBuffer readstring pop
		} bd
	}ifelse

	/stripHeight																% height of image strip
		$lly $ury sub stripRows mul $hei div
	def

	/stripOutBuffer															% buffer for strip data converted for output
		$wid stripRows mul numPlanes mul 65535 min string
	def

	/strip_img_dict 8 dict def
	strip_img_dict begin
		/ImageType 1 def													% image type - there's only 1
		/Width $wid def														% source width
 		/Height stripRows def         						% source height
		/BitsPerComponent $bts def 								% bits per sample
 		/Decode
			[numPlanes {0 1} repeat] def						% decode output strip data
		/ImageMatrix 															% map unit square to source
			[ $wid 0 0 stripRows neg 0
				$hei 0 gt	{stripRows}{0}	ifelse			% matrix( upside down if $hei is negative )
			]
		def
 		/DataSource stripOutBuffer def						%	data source decode the entire bitmap
	end
} bd

%----------------------------------------------------------------------------
% Proc:		separate_output_color_image
% Stack: 	--> separate_output_color_image --> separated
%				separated - true if image has been separated to current plate
% Desc: 		separates color or grayscale image according to global
%				separation parameters and then outputs it
%----------------------------------------------------------------------------
/separate_output_color_image
{
	/plateContent false def
	$ncl 1 eq
	{
		% grayscale image, separate to Black plate
		SeparationPlateName /Black eq
		{
			% output monochrome image to Black plate
			output_color_image
			/plateContent true def
		} if
	}
	{
		% separate DeviceN, CMYK or RGB image
		@np          									% no path but clipping

		/DataSource create_datasource def

		SeparateInColor
		{
			DocCmykSpace setcolorspace 			% CMYK colorspace for painting separation plates in color
			/numPlanes 4 def
		}
		{
			DocGrayScaleSpace setcolorspace % grayscale for default painting separation plates in black
			/numPlanes 1 def
		} ifelse

		% claculate strip size  ( in image rows )  to fit PostScript string length limit of 65535
		/stripRows 65535 $wid $bts mul $ncl numPlanes max mul 8 div div floor cvi 1 max def

		numPlanes stripRows set_image_strip_parameters

		/maxStripIndex $hei stripRows div ceiling cvi 1 sub def

		0 1 maxStripIndex 					% iterate through strips
		{
			/stripIndex exch def			% save buffer index

			/$t_ury										% calculate rectangle for strip image
				$ury stripHeight stripIndex mul add ceiling cvi
			def

			/$t_lly											% calculate rectangle for strip image
				$t_ury stripHeight add ceiling cvi
			def

			stripIndex maxStripIndex eq % last strip, adjust strip size to fit all data that remains
			{
				numPlanes $hei maxStripIndex stripRows mul sub set_image_strip_parameters

				/$t_lly										% adjust strip image rectangle
					$t_ury stripHeight add ceiling cvi
				def
			} if

			readstrip pop								% read image data from the file

			@gs

			% separate color for each image pixel
			0 1 $wid stripRows mul 1 sub
			{
				/pixelIndex xd

				stripBuffer pixelIndex $ncl mul $ncl getinterval			% get color values array for single pixel from image strip

				{ 255 div } forall																		% image colors are 0..255 encoded, convert to 0.0..1.0

				% convert pixel color
				DevicenImage
				{
						ImageDevicenSpace create_devicen_color
				}
				{
					$ncl 3 eq
					{
						create_rgb_color
					}
					{
						create_cmyk_color
					} ifelse
				} ifelse

				/separate_color dexec

				{	% check if color has been separated to the current plate
					/plateContent true def
					% extract color values from colorspec
					begin
						color aload pop
					end
				}
				{
					pop numPlanes [ numPlanes 1 eq {1}{0}ifelse ] cvx repeat
				} ifelse


				numPlanes array astore																% pack alt colors value into array

				/pixelSepIndex pixelIndex numPlanes mul def

				/posColorant 0 def
				{
				 stripOutBuffer pixelSepIndex posColorant add 3 -1 roll 255 mul cvi put
				 /posColorant posColorant 1 add def										% put alt color values into separated strip buffer
				} forall
			} for

			$llx $t_lly Tl								% translate gstate origin
			$urx $llx sub
			$t_ury $t_lly sub scale				% set current scale for bitmap size

			strip_img_dict								% scanline image dictionary
			image													% draw image

			@gr
		}for

	  $SDF {$dsf $dsa $dsp @ss}if  		% reset default halftone screen
	} ifelse

	plateContent											% leave separation flag on stack
} bd

%----------------------------------------------------------------------------
% Proc:		separate_output_monochrome_image
% Stack: 	--> separate_output_monochrome_image --> separated
%				separated - true if image has been separated to current plate
% Desc: 		separates monochrome image according to global
%				separation parameters and then outputs it
%----------------------------------------------------------------------------
/separate_output_monochrome_image
{
	SeparationPlateName /Black eq
	{
		% output monochrome image to Black plate
		output_monochrome_image true
	}
	{
		false
	} ifelse
} bd

%----------------------------------------------------------------------------
% Proc: 	output_monochrome_image
% Stack:  --> output_monochrome_image -->
% Desc: 	Outputs Grayscale/Mono bitmap
%----------------------------------------------------------------------------
/output_monochrome_image
{
	$frg 1 eq                 			% Check if foreground flag is set.
	{
		OutlineOverprint safe_setoverprint
		ImageForegroundColor /separate_set_color dexec		% Set foreground color
		{1}{0}ifelse
		/$frg xd
	}
	{
		/$frg false def
	} ifelse

	$bkg 1 eq                 % Check if background flag is set.
	{                      		% Not set for bitmap fill.
	 @gs $ctm setmatrix
	 F
	 @gr
	} if

	@np          								% no path but clipping

	/$dat $wid $bts mul 8 div ceiling cvi 65535 min string def    % string for data entry (each scan line)

	$bkg $frg add 1 ge
	{
		$SDF {$SCF $SCA $SCP @ss}if % alternate halftone screen? (determined by stroke attribs)
																% set params for the imagemask/image operator
		$llx $lly Tl
		$urx $llx sub $ury $lly sub scale

		% For monochrome bitmaps, the foreground colour is currently set.
		$bkg 1 eq
		{
		 FillColor /separate_set_color dexec pop
		} if

		$wid $hei abs          			% if height is negative, print it upside down
		$bts 1 eq
		{$bkg 1 ge }
		{$bts 1 ge }
		ifelse 											% either false or #bits/sample
		[ $wid 0 0
			$hei neg 0
			$hei 0 gt{$hei}{0}ifelse] % matrix(upside down if $hei is negative)
		/tcc load             			% @cc can be redefined
		$bts 1 eq
		{imagemask}
		{image}
		ifelse

		$SDF {$dsf $dsa $dsp @ss}if % reset default halftone screen
	}
	{
		$hei abs {tcc pop} repeat   % skip all lines
	} ifelse
} bd

%----------------------------------------------------------------------------
% Proc: 		output_color_image_level1
% Stack: 	--> output_color_image_level1 -->
% Desc: 		Outputs color bitmap on level 1 device
%----------------------------------------------------------------------------
/output_color_image_level1
{
	@np          								     % no path but clipping
	$ngx    											   % set screening function

	$llx $lly Tl
	$urx $llx sub
	$ury $lly sub scale              % set current scale for bitmap size
																	 % set parameters on stack for colorimage call:
	$wid $hei abs $bts        		   % width height #bits matrix
	[ $wid 0 0
	 $hei neg 0
	 $hei 0 gt{$hei}{0}ifelse        % matrix(upside down if $hei is negative)
	]

	/$dat $wid $bts mul $ncl mul
	8 div ceiling cvi 65535 min string def     % string for data entry (each scan line)

	$msimage false eq
	$ncl 1 eq or
	{                                % single-stream colorimage or grayscale
	 /@cc load
	 false $ncl
	 ColorImage              			   % colorimage redefined.
	}
	{                                % set parameters for multi-stream colorimage
	 $wid $bts mul 8 div ceiling cvi % calculate length of string
	 $ncl 3 eq
	 {                               % RGB colorimage
		 dup dup
		 /$dat1 exch string def        % string for data entry, Red component.
		 /$dat2 exch string def        % string for data entry, Green component.
		 /$dat3 exch string def        % string for data entry, Blue component.
		 /@cc1 load
		 /@cc2 load
		 /@cc3 load
	 }
	 {                               % CMYK colorimage
		 dup dup dup
		 /$dat1 exch string def        % string for data entry, Cyan component.
		 /$dat2 exch string def        % string for data entry, Magenta component.
		 /$dat3 exch string def        % string for data entry, Yellow component.
		 /$dat4 exch string def        % string for data entry, Black component.
		 /@cc1 load
		 /@cc2 load
		 /@cc3 load
		 /@cc4 load
	 } ifelse
	 true $ncl ColorImage
	} ifelse

	$SDF {$dsf $dsa $dsp @ss} if      % reset default halftone screen
} bd

%----------------------------------------------------------------------------
% Proc: 	@cc1
% Stack: 	- @cc1 string
% Desc: 	collect bitmap data from currentfile (input)
%----------------------------------------------------------------------------
/@cc1
{
 currentfile $dat1 readhexstring pop
} bd

%----------------------------------------------------------------------------
% Proc: 	@cc2
% Stack: 	- @cc2 string
% Desc: 	collect bitmap data from currentfile (input)
%----------------------------------------------------------------------------
/@cc2
{
 currentfile $dat2 readhexstring pop
} bd

%----------------------------------------------------------------------------
% Proc: 	@cc3
% Stack: 	- @cc3 string
% Desc: 	collect bitmap data from currentfile (input)
%----------------------------------------------------------------------------
/@cc3
{
 currentfile $dat3 readhexstring pop
} bd

%----------------------------------------------------------------------------
% Proc: 	@cc4
% Stack: 	- @cc4 string
% Desc: 	collect bitmap data from currentfile (input)
%----------------------------------------------------------------------------
/@cc4
{
 currentfile $dat4 readhexstring pop
} bd

%----------------------------------------------------------------------------
% Multi-Stream Image ($msimage)
% sets the default value for the $msimage operator.
%
% false : the image contains one data stream
% true  : the image data is specified in multi-stream input
%----------------------------------------------------------------------------
/$msimage false def

%----------------------------------------------------------------------------
% sets the default value for the compression method, by default
% we do NOT use any filters,
%
% 0 : no compression is set
% 1 : indicates a JPEG compression filter
% 2 : a Run Length Encoding filter
% 3 : LZW compression filter
%----------------------------------------------------------------------------
/ImageCompression /None def
/MaskedImage false def

/DevicenImage false def

%----------------------------------------------------------------------------
% Proc: 		output_color_image
% Stack: 	--> output_color_image -->
% Desc: 		Output color bitmap using Level 2 image dictionary
%----------------------------------------------------------------------------
/output_color_image
{
	@np          									% no path but clipping

	$ncl 1 eq											% set device color space
	{DocGrayScaleSpace}						%	use document's grayscale colorspace
	{
		$ncl 3 eq
		{DocRgbSpace}								%	use document's RGB colorspace
		{DocCmykSpace}							%	use document's CMYK colorspace
		ifelse
	} ifelse
	setcolorspace

	/$dat $wid $bts mul $ncl mul
	8 div ceiling cvi 65535 min string def 	% string for data entry (each scan line)

	$ngx    											% set screening function

	$llx $lly Tl									% translate gstate origin
	$urx $llx sub $ury $lly sub scale  % set current scale for bitmap size

	8 dict begin                 	% start a Level 2 image dictionary
		/ImageType 1 def            % required: image type - there's only 1
		/Width $wid def							%	required: source width
		/Height $hei abs def        % required: source height
		/BitsPerComponent $bts def 	%	required: bits per sample
		/Decode                     % required: decode array (to follow)
			[ $ncl { 0 1 } repeat ]		% create decode array for DeviceN image
		def
		/ImageMatrix 								% required: map unit square to source
			[ $wid 0 0 $hei neg 0
				$hei 0 gt	{$hei}{0}	ifelse
			]
		def                      		% matrix(upside down if $hei is negative)
		/DataSource create_datasource def
	currentdict end              	% end image dictionary
	image			              			% call the image operator
	$SDF {$dsf $dsa $dsp @ss}if  	% reset default halftone screen
} bd

%----------------------------------------------------------------------------
% Proc: 		simulate_devicen_image
% Stack: 	--> simulate_devicen_image -->
% Desc: 		simulating DeviceN image on Level 2 device by overprinting n  single-channel images
% Notes:		as there is not enough memory to hold whole image we output image strip by strips
%----------------------------------------------------------------------------
/simulate_devicen_image
{
	@np          										% no path but clipping
	$ngx    												% set screening function

	/colorantNames	ImageDevicenSpace 1 get def		% get DeviceN colorants name
	/altColorSpace ImageDevicenSpace 2 get	def		% get DeviceN alternative colorspace
	/tintProc ImageDevicenSpace 3 get def					% get tint procedure to convert from DeviceN to alt colorspace

	/DataSource create_datasource def

	% claculate strip size  ( in image rows )  to fit PostScript string length limit of 65535
	/stripRows 65535 $wid $bts mul $ncl mul 8 div div floor cvi 1 max def

	1 stripRows set_image_strip_parameters

	/maxStripIndex $hei stripRows div ceiling cvi 1 sub def

	0 1 maxStripIndex						% iterate through strips
	{
		/stripIndex exch def			% save buffer index

		/$t_ury										% calculate rectangle for strip image
			$ury stripHeight stripIndex mul add ceiling cvi
		def

		/$t_lly										% calculate rectangle for strip image
			$t_ury stripHeight add ceiling cvi
		def

		stripIndex maxStripIndex eq % last strip, adjust strip size to fit all data that remains
		{
			1 $hei maxStripIndex stripRows mul sub set_image_strip_parameters

			/$t_lly										% adjust strip image rectangle
				$t_ury stripHeight add ceiling cvi
			def
		} if

		readstrip pop							% read image data from the file

		% simulate DeviceN output by overprinting n single channel images
		@gs

		$llx $t_lly Tl					% translate gstate origin
		$urx $llx sub
		$t_ury $t_lly sub
		scale										% set current scale for bitmap size

		0 1 $ncl 1 sub						% iterate through DeviceN plates
		{
			@gs
			/inkIndex exch def			% save current DeviceN plate index

			0 1 stripOutBuffer length 1 sub
			{
				dup
				$ncl mul inkIndex add stripBuffer exch get
				stripOutBuffer 3 1 roll put
			}for

			[ /Separation colorantNames inkIndex  get altColorSpace
				{																					% construct one channel tint transform function
					$ncl 1 sub {0} repeat										% convert single colorant color into n-channel DeviceN color
					$ncl inkIndex roll
					tintProc																% convert DeviceN color into alternative colorspace
				}
			] setcolorspace

			inkIndex 0 gt
			{
				true setoverprint
			} if

			strip_img_dict image		% draw single scanline image

			@gr			              	% restore graphics state
		}for
		@gr
	}for

  $SDF {$dsf $dsa $dsp @ss}if  				% reset default halftone screen
} bd

%----------------------------------------------------------------------------
% Proc: 		output_devicen_image_alt
% Stack: 	--> output_devicen_image_alt -->
% Desc: 		outputing DeviceN image to Level 2 device in alternative colorspace
%----------------------------------------------------------------------------
/output_devicen_image_alt
{
	@np          										% no path but clipping
	$ngx    												% set screening function

	/colorantNames	ImageDevicenSpace 1 get def		% get DeviceN colorants name
	/altColorSpace ImageDevicenSpace 2 get	def		% get DeviceN alternative colorspace
	/tintProc ImageDevicenSpace 3 get def					% get tint procedure to convert from DeviceN to alt colorspace

	% determine how many colorants are in alternative colorspace
	altColorSpace DocCmykSpace eq
	{
		/numAltChannels 4 def
	}
	{
		altColorSpace DocRgbSpace eq
		{
			/numAltChannels 3 def
		}
		{
			/numAltChannels 1 def
		} ifelse
	}ifelse

	/DataSource create_datasource def
	
	altColorSpace setcolorspace			% use alternative colorspace

	% claculate strip size  ( in image rows )  to fit PostScript string length limit of 65535
	/stripRows 65535 $wid $bts mul $ncl numAltChannels max mul 8 div div floor cvi 1 max def

	numAltChannels stripRows set_image_strip_parameters

	/maxStripIndex $hei stripRows div ceiling cvi 1 sub def

	0 1 maxStripIndex 							% iterate through strips
	{
		/stripIndex exch def			% save buffer index

		/$t_ury										% calculate rectangle for strip image
			$ury stripHeight stripIndex mul add ceiling cvi
		def

		/$t_lly										% calculate rectangle for strip image
			$t_ury stripHeight add ceiling cvi
		def

		stripIndex maxStripIndex eq % last strip, adjust strip size to fit all data that remains
		{
			numAltChannels $hei maxStripIndex stripRows mul sub set_image_strip_parameters

			/$t_lly										% adjust strip image rectangle
				$t_ury stripHeight add ceiling cvi
			def
		} if

		readstrip pop							% read image data from the file

		@gs

		% output DeviceN image in alternative colorspace
		0 1 stripBuffer length $ncl div cvi 1 sub
		{
			/pixelIndex xd

			stripBuffer pixelIndex $ncl mul $ncl getinterval			% get DeviceN color values array for single pixel from image scanline

			{ 255 div } forall																		% image colors are 0..255 encoded, convert to 0.0..1.0

			tintProc exec																					% convert DeviceN 0.0..1.0 encoded color values to alt colorspace

			numAltChannels array astore														% pack alt colors value into array

			/pixelAltIndex pixelIndex numAltChannels mul def

			/posColorant 0 def
			{
			 stripOutBuffer pixelAltIndex posColorant add 3 -1 roll 255 mul cvi put
			 /posColorant posColorant 1 add def										% put alt color values into alt colorspace scanline
			} forall
		} for

		$llx $t_lly Tl								% translate gstate origin
		$urx $llx sub
		$t_ury $t_lly sub scale				% set current scale for bitmap size

		strip_img_dict								% scanline image dictionary
		image													% draw image

		@gr
	}for

  $SDF {$dsf $dsa $dsp @ss}if  				% reset default halftone screen
} bd

%----------------------------------------------------------------------------
% Proc: 		output_devicen_image_native
% Stack: 	--> output_devicen_image_native -->
% Desc: 		Output DeviceN image natively in Level3
%----------------------------------------------------------------------------
/output_devicen_image_native
{
	@np          											% no path but clipping
	$ngx    													% set screening function

	ImageDevicenSpace setcolorspace		% set DeviceN colorspace

	/scanline
		$wid $bts
		mul $ncl mul
		8 div
		ceiling cvi 65535 min string
	def 															% string for scanline data

	/readscanline
	{
		currentfile	scanline readhexstring pop
	} bind def

	$llx $lly Tl											% translate gstate origin
	$urx $llx sub $ury $lly sub scale % set current scale for bitmap size

	8 dict begin                 			% start a Level 2 image dictionary
		/ImageType 1 def             		% image type - there's only 1
		/Width $wid def									%	source width
		/Height $hei abs def         		% source height
		/BitsPerComponent $bts def 			%	bits per sample
		/Decode                     		% decode array (to follow)
			[ $ncl { 0 1 } repeat ]				% create decode array for DeviceN image
		def
		/ImageMatrix 										% required: map unit square to source
		[ $wid 0 0 $hei neg 0
				$hei 0 gt	{$hei}{0}	ifelse
		]	def                      			% matrix(upside down if $hei is negative)
		/DataSource											%	required: data source decode the entire bitmap
		{
			readscanline
		} def
	currentdict end              			% end image dictionary

	image			              					% call the image operator

  $SDF {$dsf $dsa $dsp @ss}if  			% reset default halftone screen
} bd


%----------------------------------------------------------------------------
% Proc: 	output_devicen_image
%
% Stack: 	pxlwid pxlhei bits ncolors llx lly urx ury cropllx croplly
%					cropurx cropury	matrix --> output_devicen_image -->
%
% Desc: 	Output DeviceN image
%
% Parms: 	colorspace				DeviceN image colorspace
%					pxlwid pxlhei 		size of bitmap in pixels
%         bits 							bits per component
%         ncolors 					color components (RGB=3, CMYK=4)
%         llx lly urx ury 	size of bitmap (before transfos)
%         cropllx croplly cropurx cropury: cropping rectangle (before transfos)
%         matrix: 					transfo matrix for stretching/rotating, etc..
%					Note :	Level 3 device - image will be output in native DeviceN colorspace
%									Level 2 Distiller or in-RIP separation - image will be output as
%									series of N overprinted bitmaps ( scanline by scanline )
%									Level 2 composite - image will be output in alternative colorspace
%
%----------------------------------------------------------------------------
/output_devicen_image
{
	Level3
	{
		output_devicen_image_native
	}
	{
		get_simulate_devicen
		{
			simulate_devicen_image
		}
		{
			output_devicen_image_alt
		} ifelse
	} ifelse
} bd

%----------------------------------------------------------------------------
% Proc: 	output_masked_image
%
% Stack: 	pxlwid pxlhei bits ncolors llx lly urx ury cropllx croplly
%					cropurx cropury	matrix output_masked_image -
%
% Desc: 	Output level 3 color bitmap with mask
%
% Parms: 	pxlwid 	:
%					pxlhei	: size of bitmap in pixels
%         bits		: bits per component
%         ncolors	: color components (RGB=3, CMYK=4)
%         llx lly urx ury: 	size of bitmap (before transfos)
%         cropllx croplly cropurx cropury: cropping rectangle (before transfos)
%         matrix	: transfo matrix for stretching/rotating, etc.
%
%----------------------------------------------------------------------------
/output_masked_image
{
	/$dat $wid $bts mul $ncl mul
	8 div ceiling cvi 65535 min string def 	% string for data entry (each scan line)
	$ngx    											% set screening function

	DevicenImage									% DeviceN image
	{
		ImageDevicenSpace
	}
	{
		$ncl 1 eq										% set device color space
		{DocGrayScaleSpace}         %	use document's grayscale colorspace
		{
			$ncl 3 eq
			{DocRgbSpace}             %	use document's RGB colorspace
			{DocCmykSpace}            %	use document's CMYK colorspace
			ifelse
		} ifelse
	} ifelse
	setcolorspace

	$llx $lly Tl									% translate gstate origin
	$urx $llx sub
	$ury $lly sub scale						% set current scale for bitmap size

	/ImageDataDict 8 dict def			% start image data dictionary
	ImageDataDict begin
		/ImageType	1 def           % modified type 1 image dictionary
		/Width			$wid def				%	required: source width
		/Height			$hei abs def    % required: source height
		/BitsPerComponent $bts def 	%	required: bits per sample
		/Decode											% required: decode array (to follow)
		[ $ncl { 0 1 } repeat ]
		def

		/ImageMatrix [ 							%	required: image matrix
			$wid 0 0 $hei neg 0
			$hei 0 gt{$hei}{0} ifelse %	matrix(upside down if $hei is negative)
 		] def

		/DataSource create_datasource def
	end                           % end image data dictionary

	/MaskedImageDict 7 dict def   % start masked image dictionary
	MaskedImageDict begin
		/ImageType 3 def            % masked image
		/InterleaveType 3 def       % mask and data appear in separate streams
		/MaskDict ImageMaskDict def % dictionary to define mask
		/DataDict ImageDataDict def % dictionary to define data
	end

  MaskedImageDict image					% do the image

	$SDF {$dsf $dsa $dsp @ss}if  	% reset default halftone screen
} bd

%----------------------------------------------------------------------------
% Proc: 	set_image_mask
% Stack: 	pxlwid pxlhei bits set_image_mask -
%
% Desc: 	Level 3 set mask for masked images
%
% Parms: 	pxlwid 	:	Width of mask in pixels
%					pxlhei	: Height of mask in pixels
%         bits		: bits per mask component, must be 1 for InterleaveType 3
%----------------------------------------------------------------------------
/set_image_mask
{
	/$mbts xd           					% store # of bits for mask
	/$mhei xd 										%	height of mask
	/$mwid xd            					% width of mask

	/ImageMaskDict 8 dict def
	ImageMaskDict begin
		/ImageType 1 def            % modified type 1 image dictionary
		/Width		 $mwid def				%	required: source width
		/Height		 $mhei abs def		% required: source height
		/BitsPerComponent $mbts def %	required: bits per sample, must be 1 for InterleaveType 3

		/DataSource maskstream def	%	required for InterleaveType 3: data source of the mask

		/ImageMatrix [ 							%	required: image matrix
			$mwid 0 0 $mhei neg 0
			$mhei 0 gt
			{$mhei}{0} ifelse					%	matrix(upside down if $hei is negative)
 		] def

		/Decode [ 1 0 ] def         % required: mask 0 values.
	end                           % end image mask dictionary
} bd

%----------------------------------------------------------------------------
% Proc:		@daq
% Stack: 	one or more <arrays of data strings | data strings> daq -
% Desc: 	standard bitmap data acquistion routine
% NOTE:		This assumes ONLY arrays of data strings or data
%         strings are on the stack and that there are ENOUGH data
%         strings (total) for the specified bitmap.
%----------------------------------------------------------------------------
/@daq
{
 dup type /arraytype eq   		% is this an array
 {
  aload pop          					% dump strings in array onto stack
 }
 if            								% otherwise, should be a string, so leave it
} bd

%----------------------------------------------------------------------------
% Proc:		skip_image_body
%
% Stack: 	pxlwid pxlhei bits bitplanes
%         llx lly urx ury backgroundflag foregroundflag
%         cropllx croplly cropurx cropury matrix
%         dataproc --> skip_image_body -->
%
% Desc: 	skip over image binary body leaving stack clean

% NOTE:		This call should be followed by enable_raster_output call to restore
%					output_image function
%----------------------------------------------------------------------------
/skip_image_body
{
	8 rp  					% get rid of parameters on stack we do not need
	/$ury xd /$urx xd       % store the image rectangle
	/$lly xd /$llx xd       % still storing the image rectangle
	/$ncl xd           		% store # of color components
	/$bts xd           		% store # of bits per color component
	/$hei xd /$wid xd       % store pixel size

	DevicenImage not
	ImageCompression /JPEG eq or
	ImageCompression /RLE eq or
	ImageCompression /LZW eq or
	{
		create_datasource flushfile
	}
	{
		/scanline			% define string to keep single string of image data
			$wid $bts
			mul $ncl mul
			8 div
			ceiling cvi
			dup 65535 gt
			{
				pop $bts $ncl mul
			}if
			string
		def

		/upperBound $wid $hei mul $bts mul $ncl mul scanline length div cvi 1 sub def 
		0 1 upperBound			% iterate through image using scanline buffer
		{
			pop
			currentfile scanline readhexstring
			pop pop				% discard whatever we read
		}for
	}ifelse
}bd

%----------------------------------------------------------------------------
% Proc:		disable_raster_output
%
% Stack: 	--> disable_raster_output -->
%
% Desc: 	overload output_image procedure by skip_image_body procedure
%					which skips image data
%
% NOTE:		This call should be followed by enable_raster_output call to restore
%					output_image function
%----------------------------------------------------------------------------
/disable_raster_output
{
	deflevel 0 eq { @rs	} if
		
	/output_image load					% load current output_image function
	/output_image_original exch	% and save it
	def													% bind it there

	/output_image /skip_image_body load def	% overload function
	
	globaldict begin /bSkipDeviceNImage true def end
	
	deflevel 0 eq { @sv	} if
}def

%----------------------------------------------------------------------------
% Proc:		enable_raster_output
% Stack: 	--> enable_raster_output -->
% Desc: 	Function restores overloaded output_image function
% NOTE:		This call should go after disable_raster_output call
%----------------------------------------------------------------------------
/enable_raster_output
{
	deflevel 0 eq { @rs	} if
	
	/bSkipDeviceNImage where		% check whether output_image has been overloaded
	{
		/bSkipDeviceNImage undef
		
		/output_image /output_image_original load def		% load original raster function and assign it to output_image
	}if
	
	deflevel 0 eq { @sv	} if
}def


end
%%EndResource
%%EndProlog
%%BeginSetup
wCorel21Dict begin
@BeginSysCorelDict
/$dcm matrix currentmatrix def
@ssa
1.00 setflat
/$fst 128 def
%%EndSetup

%%Page: 1 1
%%ViewingOrientation: 1 0 0 1
%%BoundingBox: 0 0 595 841
%LogicalPage: 1
%%BeginPageSetup
@sv
@sm
@sv
%%EndPageSetup
@rax %Note: Object
34.59798 47.99509 573.17272 778.93880 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
573.17272 762.57780 m
573.17272 778.37187 L
304.08378 778.93880 L
34.59798 778.37187 L
34.59798 762.57780 L
40.32198 762.57780 L
40.32198 762.58772 L
82.59109 762.30482 L
66.82110 760.29477 54.32117 747.79483 52.31112 732.01493 C
52.31112 731.64472 L
36.23414 731.64472 L
36.23414 709.60280 L
43.51011 709.60280 L
45.83707 709.60280 47.73997 707.69991 47.73997 705.37294 C
47.73997 649.72687 L
47.73997 647.39991 45.83707 645.49672 43.51011 645.49672 C
36.23414 645.49672 L
36.23414 450.34526 L
43.62009 450.34526 L
46.50520 450.34526 48.86419 447.98513 48.86419 445.10003 C
48.86419 382.08898 L
48.86419 379.20416 46.50520 376.84403 43.62009 376.84403 C
36.23414 376.84403 L
36.23414 167.51764 L
42.08683 167.51764 L
45.95669 167.68517 47.89020 166.03767 47.76038 162.45496 C
47.72324 127.52107 L
47.75187 123.98343 46.04117 122.18542 42.32013 122.39802 C
36.23414 122.32998 L
36.23414 94.17118 L
52.30998 94.17118 L
52.31112 93.78510 L
54.32117 78.00520 66.84094 65.48513 82.63106 63.50513 C
35.87613 63.50513 L
35.87613 47.99509 L
571.99890 47.99509 L
571.99890 63.50513 L
525.82082 63.50513 L
541.60186 65.48315 554.10888 77.97515 556.14189 93.72813 C
556.14189 94.17118 L
572.21773 94.17118 L
572.21773 731.65181 L
556.15181 731.55090 L
556.15068 731.97496 L
554.17068 747.77471 541.65090 760.29477 525.86079 762.30482 C
567.73276 762.58772 L
567.73276 762.57780 L
573.17272 762.57780 L
@c
S

@rax %Note: Object
320.92469 769.36989 325.35184 773.79789 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
323.13770 773.79789 m
324.36794 773.79789 325.35184 772.79981 325.35184 771.58375 C
325.35184 770.35493 324.36794 769.36989 323.13770 769.36989 C
321.92277 769.36989 320.92469 770.35493 320.92469 771.58375 C
320.92469 772.79981 321.92277 773.79789 323.13770 773.79789 C
@c
S

@rax %Note: Object
305.22926 447.92901 324.35631 469.03805 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
305.42088 450.63921 m
306.76082 458.35909 310.67093 463.72904 317.38082 467.04813 C
319.72082 468.20806 321.96076 468.85918 324.21090 469.03805 C
324.31068 469.03805 L
324.31068 468.69902 324.32088 468.36822 324.33080 468.03798 C
324.36085 467.12806 324.38069 466.25811 324.29083 465.39921 C
323.66069 459.79824 321.31077 455.92214 316.41080 451.76202 C
314.30069 449.97222 311.26876 448.74907 308.49874 448.20000 C
307.88787 448.07924 307.22882 447.99902 306.55871 447.94998 C
306.32882 447.92901 306.13776 447.92901 305.95890 447.92901 C
305.95890 447.92901 305.35767 447.93921 305.24882 447.93921 C
305.21083 448.86614 305.21083 449.40813 305.42088 450.63921 C
@c
S

@rax %Note: Object
282.80494 769.36989 287.23209 773.79789 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
285.01795 773.79789 m
286.24819 773.79789 287.23209 772.79981 287.23209 771.58375 C
287.23209 770.35493 286.24819 769.36989 285.01795 769.36989 C
283.80302 769.36989 282.80494 770.35493 282.80494 771.58375 C
282.80494 772.79981 283.80302 773.79789 285.01795 773.79789 C
@c
S

@rax %Note: Object
81.07710 679.80189 92.63707 691.37178 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
86.85694 679.80189 m
83.65720 679.80189 81.07710 682.39191 81.07710 685.58173 C
81.07710 688.78176 83.65720 691.37178 86.85694 691.37178 C
90.04706 691.37178 92.63707 688.78176 92.63707 685.58173 C
92.63707 682.39191 90.04706 679.80189 86.85694 679.80189 C
@c
S

@rax %Note: Object
84.58498 698.17294 89.12920 702.70186 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
84.58498 700.44576 m
84.58498 701.69386 85.60800 702.70186 86.85694 702.70186 C
88.10617 702.70186 89.12920 701.69386 89.12920 700.44576 C
89.12920 699.18094 88.10617 698.17294 86.85694 698.17294 C
85.60800 698.17294 84.58498 699.18094 84.58498 700.44576 C
@c
S

@rax %Note: Object
68.03717 709.15578 105.66709 746.78485 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
86.85694 709.15578 m
76.46712 709.15578 68.03717 717.58488 68.03717 727.97584 C
68.03717 738.36595 76.46712 746.78485 86.85694 746.78485 C
97.24819 746.78485 105.66709 738.36595 105.66709 727.97584 C
105.66709 717.58488 97.24819 709.15578 86.85694 709.15578 C
@c
S

@rax %Note: Object
87.26003 768.13172 121.91017 775.77591 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
118.08822 768.13172 m
91.08198 768.13172 L
88.97102 768.13172 87.26003 769.84271 87.26003 771.95282 C
87.26003 774.06491 88.97102 775.77591 91.08198 775.77591 C
118.08822 775.77591 L
120.19918 775.77591 121.91017 774.06491 121.91017 771.95282 C
121.91017 769.84271 120.19918 768.13172 118.08822 768.13172 C
@c
S

@rax %Note: Object
129.64422 52.96819 134.07420 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
131.86403 52.96819 m
130.63408 52.96819 129.64422 53.95805 129.64422 55.17808 C
129.64422 56.39811 130.63408 57.39817 131.86403 57.39817 C
133.08406 57.39817 134.07420 56.39811 134.07420 55.17808 C
134.07420 53.95805 133.08406 52.96819 131.86403 52.96819 C
@c
S

@rax %Note: Object
129.60397 769.40277 134.46397 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
132.03411 769.40277 m
130.69417 769.40277 129.60397 770.48277 129.60397 771.83178 C
129.60397 773.17172 130.69417 774.26192 132.03411 774.26192 C
133.37405 774.26192 134.46397 773.17172 134.46397 771.83178 C
134.46397 770.48277 133.37405 769.40277 132.03411 769.40277 C
@c
S

@rax %Note: Object
135.65395 52.96819 140.08422 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
137.87405 52.96819 m
136.64409 52.96819 135.65395 53.95805 135.65395 55.17808 C
135.65395 56.39811 136.64409 57.39817 137.87405 57.39817 C
139.09408 57.39817 140.08422 56.39811 140.08422 55.17808 C
140.08422 53.95805 139.09408 52.96819 137.87405 52.96819 C
@c
S

@rax %Note: Object
135.72397 769.40277 140.58397 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
138.15411 769.40277 m
136.80397 769.40277 135.72397 770.48277 135.72397 771.83178 C
135.72397 773.17172 136.80397 774.26192 138.15411 774.26192 C
139.49405 774.26192 140.58397 773.17172 140.58397 771.83178 C
140.58397 770.48277 139.49405 769.40277 138.15411 769.40277 C
@c
S

@rax %Note: Object
141.66397 52.96819 146.09395 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
143.88406 52.96819 m
142.66403 52.96819 141.66397 53.95805 141.66397 55.17808 C
141.66397 56.39811 142.66403 57.39817 143.88406 57.39817 C
145.10409 57.39817 146.09395 56.39811 146.09395 55.17808 C
146.09395 53.95805 145.10409 52.96819 143.88406 52.96819 C
@c
S

@rax %Note: Object
141.66397 769.40277 146.52397 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
144.09411 769.40277 m
142.75417 769.40277 141.66397 770.48277 141.66397 771.83178 C
141.66397 773.17172 142.75417 774.26192 144.09411 774.26192 C
145.44397 774.26192 146.52397 773.17172 146.52397 771.83178 C
146.52397 770.48277 145.44397 769.40277 144.09411 769.40277 C
@c
S

@rax %Note: Object
147.64422 52.96819 152.07420 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
149.86403 52.96819 m
148.63408 52.96819 147.64422 53.95805 147.64422 55.17808 C
147.64422 56.39811 148.63408 57.39817 149.86403 57.39817 C
151.08406 57.39817 152.07420 56.39811 152.07420 55.17808 C
152.07420 53.95805 151.08406 52.96819 149.86403 52.96819 C
@c
S

@rax %Note: Object
147.74400 769.40277 152.60400 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
150.17414 769.40277 m
148.83420 769.40277 147.74400 770.48277 147.74400 771.83178 C
147.74400 773.17172 148.83420 774.26192 150.17414 774.26192 C
151.51408 774.26192 152.60400 773.17172 152.60400 771.83178 C
152.60400 770.48277 151.51408 769.40277 150.17414 769.40277 C
@c
S

@rax %Note: Object
153.73417 52.96819 158.15395 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
155.94406 52.96819 m
154.72403 52.96819 153.73417 53.95805 153.73417 55.17808 C
153.73417 56.39811 154.72403 57.39817 155.94406 57.39817 C
157.16409 57.39817 158.15395 56.39811 158.15395 55.17808 C
158.15395 53.95805 157.16409 52.96819 155.94406 52.96819 C
@c
S

@rax %Note: Object
153.81411 769.40277 158.67411 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
156.24397 769.40277 m
154.89411 769.40277 153.81411 770.48277 153.81411 771.83178 C
153.81411 773.17172 154.89411 774.26192 156.24397 774.26192 C
157.58419 774.26192 158.67411 773.17172 158.67411 771.83178 C
158.67411 770.48277 157.58419 769.40277 156.24397 769.40277 C
@c
S

@rax %Note: Object
159.56419 52.96819 163.98397 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
161.77408 52.96819 m
160.55405 52.96819 159.56419 53.95805 159.56419 55.17808 C
159.56419 56.39811 160.55405 57.39817 161.77408 57.39817 C
162.99411 57.39817 163.98397 56.39811 163.98397 55.17808 C
163.98397 53.95805 162.99411 52.96819 161.77408 52.96819 C
@c
S

@rax %Note: Object
159.79408 769.40277 164.65408 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
162.22422 769.40277 m
160.87408 769.40277 159.79408 770.48277 159.79408 771.83178 C
159.79408 773.17172 160.87408 774.26192 162.22422 774.26192 C
163.56416 774.26192 164.65408 773.17172 164.65408 771.83178 C
164.65408 770.48277 163.56416 769.40277 162.22422 769.40277 C
@c
S

@rax %Note: Object
165.71395 52.96819 170.13402 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
167.92413 52.96819 m
166.70409 52.96819 165.71395 53.95805 165.71395 55.17808 C
165.71395 56.39811 166.70409 57.39817 167.92413 57.39817 C
169.14416 57.39817 170.13402 56.39811 170.13402 55.17808 C
170.13402 53.95805 169.14416 52.96819 167.92413 52.96819 C
@c
S

@rax %Note: Object
165.72416 769.40277 170.58416 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
168.15402 769.40277 m
166.81408 769.40277 165.72416 770.48277 165.72416 771.83178 C
165.72416 773.17172 166.81408 774.26192 168.15402 774.26192 C
169.49395 774.26192 170.58416 773.17172 170.58416 771.83178 C
170.58416 770.48277 169.49395 769.40277 168.15402 769.40277 C
@c
S

@rax %Note: Object
171.79398 52.96819 176.22397 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
174.01408 52.96819 m
172.78413 52.96819 171.79398 53.95805 171.79398 55.17808 C
171.79398 56.39811 172.78413 57.39817 174.01408 57.39817 C
175.23411 57.39817 176.22397 56.39811 176.22397 55.17808 C
176.22397 53.95805 175.23411 52.96819 174.01408 52.96819 C
@c
S

@rax %Note: Object
171.78406 769.40277 176.64406 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
174.21420 769.40277 m
172.87398 769.40277 171.78406 770.48277 171.78406 771.83178 C
171.78406 773.17172 172.87398 774.26192 174.21420 774.26192 C
175.55414 774.26192 176.64406 773.17172 176.64406 771.83178 C
176.64406 770.48277 175.55414 769.40277 174.21420 769.40277 C
@c
S

@rax %Note: Object
177.89414 52.96819 182.31420 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
180.10403 52.96819 m
178.88400 52.96819 177.89414 53.95805 177.89414 55.17808 C
177.89414 56.39811 178.88400 57.39817 180.10403 57.39817 C
181.32406 57.39817 182.31420 56.39811 182.31420 55.17808 C
182.31420 53.95805 181.32406 52.96819 180.10403 52.96819 C
@c
S

@rax %Note: Object
177.77395 769.40277 182.64416 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
180.21402 769.40277 m
178.86416 769.40277 177.77395 770.48277 177.77395 771.83178 C
177.77395 773.17172 178.86416 774.26192 180.21402 774.26192 C
181.55395 774.26192 182.64416 773.17172 182.64416 771.83178 C
182.64416 770.48277 181.55395 769.40277 180.21402 769.40277 C
@c
S

@rax %Note: Object
183.89395 52.96819 188.31402 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
186.10413 52.96819 m
184.88409 52.96819 183.89395 53.95805 183.89395 55.17808 C
183.89395 56.39811 184.88409 57.39817 186.10413 57.39817 C
187.32416 57.39817 188.31402 56.39811 188.31402 55.17808 C
188.31402 53.95805 187.32416 52.96819 186.10413 52.96819 C
@c
S

@rax %Note: Object
183.83414 769.40277 188.69414 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
186.26400 769.40277 m
184.92406 769.40277 183.83414 770.48277 183.83414 771.83178 C
183.83414 773.17172 184.92406 774.26192 186.26400 774.26192 C
187.61414 774.26192 188.69414 773.17172 188.69414 771.83178 C
188.69414 770.48277 187.61414 769.40277 186.26400 769.40277 C
@c
S

@rax %Note: Object
189.76422 52.96819 194.19420 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
191.97411 52.96819 m
190.75408 52.96819 189.76422 53.95805 189.76422 55.17808 C
189.76422 56.39811 190.75408 57.39817 191.97411 57.39817 C
193.20406 57.39817 194.19420 56.39811 194.19420 55.17808 C
194.19420 53.95805 193.20406 52.96819 191.97411 52.96819 C
@c
S

@rax %Note: Object
189.88413 769.40277 194.75405 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
192.32419 769.40277 m
190.97405 769.40277 189.88413 770.48277 189.88413 771.83178 C
189.88413 773.17172 190.97405 774.26192 192.32419 774.26192 C
193.66413 774.26192 194.75405 773.17172 194.75405 771.83178 C
194.75405 770.48277 193.66413 769.40277 192.32419 769.40277 C
@c
S

@rax %Note: Object
195.79408 52.96819 200.22406 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
198.01417 52.96819 m
196.78422 52.96819 195.79408 53.95805 195.79408 55.17808 C
195.79408 56.39811 196.78422 57.39817 198.01417 57.39817 C
199.23420 57.39817 200.22406 56.39811 200.22406 55.17808 C
200.22406 53.95805 199.23420 52.96819 198.01417 52.96819 C
@c
S

@rax %Note: Object
195.95395 769.40277 200.81395 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
198.38409 769.40277 m
197.04416 769.40277 195.95395 770.48277 195.95395 771.83178 C
195.95395 773.17172 197.04416 774.26192 198.38409 774.26192 C
199.72403 774.26192 200.81395 773.17172 200.81395 771.83178 C
200.81395 770.48277 199.72403 769.40277 198.38409 769.40277 C
@c
S

@rax %Note: Object
201.76413 52.96819 206.19411 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
203.97402 52.96819 m
202.75398 52.96819 201.76413 53.95805 201.76413 55.17808 C
201.76413 56.39811 202.75398 57.39817 203.97402 57.39817 C
205.20397 57.39817 206.19411 56.39811 206.19411 55.17808 C
206.19411 53.95805 205.20397 52.96819 203.97402 52.96819 C
@c
S

@rax %Note: Object
201.95405 769.40277 206.81405 774.26192 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
204.38419 769.40277 m
203.04397 769.40277 201.95405 770.48277 201.95405 771.83178 C
201.95405 773.17172 203.04397 774.26192 204.38419 774.26192 C
205.73405 774.26192 206.81405 773.17172 206.81405 771.83178 C
206.81405 770.48277 205.73405 769.40277 204.38419 769.40277 C
@c
S

@rax %Note: Object
284.12419 92.09112 295.41402 103.39115 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
284.12419 97.74113 m
284.12419 100.86208 286.64419 103.39115 289.76400 103.39115 C
292.88409 103.39115 295.41402 100.86208 295.41402 97.74113 C
295.41402 94.62104 292.88409 92.09112 289.76400 92.09112 C
286.64419 92.09112 284.12419 94.62104 284.12419 97.74113 C
@c
S

@rax %Note: Object
291.50419 51.08825 316.24072 59.56214 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
312.00378 51.08825 m
295.74113 51.08825 L
293.40113 51.08825 291.50419 52.98520 291.50419 55.32520 C
291.50419 57.66406 293.40113 59.56214 295.74113 59.56214 C
312.00378 59.56214 L
314.34378 59.56214 316.24072 57.66406 316.24072 55.32520 C
316.24072 52.98520 314.34378 51.08825 312.00378 51.08825 C
@c
S

@rax %Note: Object
298.16419 92.09112 309.46394 103.39115 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
298.16419 97.74113 m
298.16419 100.86208 300.69383 103.39115 303.81392 103.39115 C
306.93373 103.39115 309.46394 100.86208 309.46394 97.74113 C
309.46394 94.62104 306.93373 92.09112 303.81392 92.09112 C
300.69383 92.09112 298.16419 94.62104 298.16419 97.74113 C
@c
S

@rax %Note: Object
312.42387 92.09112 323.72391 103.39115 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
318.07389 92.09112 m
314.95380 92.09112 312.42387 94.62104 312.42387 97.74113 C
312.42387 100.86208 314.95380 103.39115 318.07389 103.39115 C
321.19370 103.39115 323.72391 100.86208 323.72391 97.74113 C
323.72391 94.62104 321.19370 92.09112 318.07389 92.09112 C
@c
S

@rax %Note: Object
265.18195 372.08183 344.83068 444.85483 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
344.53077 395.69924 m
344.24079 394.89902 343.94088 394.07811 343.63077 393.26910 C
341.74091 388.44907 339.21071 384.77622 335.18069 379.66507 C
332.23493 375.95112 328.42885 372.23206 323.36986 372.16715 C
317.65691 372.09402 312.86778 376.24507 307.01083 376.24507 C
304.18271 376.24507 301.58986 375.69798 298.99474 374.59701 C
296.42003 373.50425 293.84617 372.09118 290.97411 372.08211 C
288.38296 372.07417 285.90094 373.25310 283.88211 374.87707 C
279.90397 378.07909 276.66510 382.22816 273.91918 386.48721 C
271.38104 390.42510 269.28822 394.64306 267.88110 399.11811 C
265.85121 405.57798 264.98098 411.59906 265.22107 417.51921 C
265.44104 422.84920 266.28094 429.70819 270.85096 435.48917 C
275.20413 440.99320 281.82501 444.71707 288.94422 444.53820 C
292.57710 444.44806 296.14904 443.49109 299.50271 442.09417 C
301.17090 441.40025 302.84079 440.58302 304.64391 440.46000 C
306.36369 440.34321 308.05767 440.86819 309.68391 441.44220 C
314.77890 443.23512 319.64882 445.30299 325.16079 444.76923 C
329.84589 444.31512 334.38472 442.79405 338.10094 439.84913 C
339.42076 438.80910 339.92674 437.90202 340.84772 436.52211 C
341.01780 436.27209 341.18787 436.02208 341.35682 435.76214 C
334.03776 431.12211 331.07074 424.21918 331.68076 415.25802 C
332.26072 406.90800 336.56088 400.76901 344.83068 396.49805 C
344.53077 395.69924 L
@c
S

@rax %Note: Object
401.29682 52.96819 405.71688 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
403.50671 52.96819 m
402.28668 52.96819 401.29682 53.95805 401.29682 55.17808 C
401.29682 56.39811 402.28668 57.39817 403.50671 57.39817 C
404.72787 57.39817 405.71688 56.39811 405.71688 55.17808 C
405.71688 53.95805 404.72787 52.96819 403.50671 52.96819 C
@c
S

@rax %Note: Object
401.07373 769.11874 405.93373 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
403.50387 769.11874 m
402.16394 769.11874 401.07373 770.19874 401.07373 771.54888 C
401.07373 772.88882 402.16394 773.97874 403.50387 773.97874 C
404.84381 773.97874 405.93373 772.88882 405.93373 771.54888 C
405.93373 770.19874 404.84381 769.11874 403.50387 769.11874 C
@c
S

@rax %Note: Object
407.30683 52.96819 411.72775 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
409.51672 52.96819 m
408.29669 52.96819 407.30683 53.95805 407.30683 55.17808 C
407.30683 56.39811 408.29669 57.39817 409.51672 57.39817 C
410.73676 57.39817 411.72775 56.39811 411.72775 55.17808 C
411.72775 53.95805 410.73676 52.96819 409.51672 52.96819 C
@c
S

@rax %Note: Object
407.15376 769.11874 412.01376 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
409.58391 769.11874 m
408.24369 769.11874 407.15376 770.19874 407.15376 771.54888 C
407.15376 772.88882 408.24369 773.97874 409.58391 773.97874 C
410.92384 773.97874 412.01376 772.88882 412.01376 771.54888 C
412.01376 770.19874 410.92384 769.11874 409.58391 769.11874 C
@c
S

@rax %Note: Object
413.31685 52.96819 417.73691 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
415.52674 52.96819 m
414.30671 52.96819 413.31685 53.95805 413.31685 55.17808 C
413.31685 56.39811 414.30671 57.39817 415.52674 57.39817 C
416.74791 57.39817 417.73691 56.39811 417.73691 55.17808 C
417.73691 53.95805 416.74791 52.96819 415.52674 52.96819 C
@c
S

@rax %Note: Object
413.12381 769.11874 417.98381 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
415.55367 769.11874 m
414.20381 769.11874 413.12381 770.19874 413.12381 771.54888 C
413.12381 772.88882 414.20381 773.97874 415.55367 773.97874 C
416.89389 773.97874 417.98381 772.88882 417.98381 771.54888 C
417.98381 770.19874 416.89389 769.11874 415.55367 769.11874 C
@c
S

@rax %Note: Object
419.29682 52.96819 423.71688 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
421.50671 52.96819 m
420.28668 52.96819 419.29682 53.95805 419.29682 55.17808 C
419.29682 56.39811 420.28668 57.39817 421.50671 57.39817 C
422.72787 57.39817 423.71688 56.39811 423.71688 55.17808 C
423.71688 53.95805 422.72787 52.96819 421.50671 52.96819 C
@c
S

@rax %Note: Object
419.24381 769.11874 424.10381 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
421.67367 769.11874 m
420.33373 769.11874 419.24381 770.19874 419.24381 771.54888 C
419.24381 772.88882 420.33373 773.97874 421.67367 773.97874 C
423.01389 773.97874 424.10381 772.88882 424.10381 771.54888 C
424.10381 770.19874 423.01389 769.11874 421.67367 769.11874 C
@c
S

@rax %Note: Object
425.37685 52.96819 429.80683 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
427.58674 52.96819 m
426.36671 52.96819 425.37685 53.95805 425.37685 55.17808 C
425.37685 56.39811 426.36671 57.39817 427.58674 57.39817 C
428.81669 57.39817 429.80683 56.39811 429.80683 55.17808 C
429.80683 53.95805 428.81669 52.96819 427.58674 52.96819 C
@c
S

@rax %Note: Object
425.18381 769.11874 430.05373 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
427.62387 769.11874 m
426.27373 769.11874 425.18381 770.19874 425.18381 771.54888 C
425.18381 772.88882 426.27373 773.97874 427.62387 773.97874 C
428.96381 773.97874 430.05373 772.88882 430.05373 771.54888 C
430.05373 770.19874 428.96381 769.11874 427.62387 769.11874 C
@c
S

@rax %Note: Object
431.20687 52.96819 435.63685 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
433.41676 52.96819 m
432.19672 52.96819 431.20687 53.95805 431.20687 55.17808 C
431.20687 56.39811 432.19672 57.39817 433.41676 57.39817 C
434.64671 57.39817 435.63685 56.39811 435.63685 55.17808 C
435.63685 53.95805 434.64671 52.96819 433.41676 52.96819 C
@c
S

@rax %Note: Object
431.12381 769.11874 435.98381 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
433.55367 769.11874 m
432.21373 769.11874 431.12381 770.19874 431.12381 771.54888 C
431.12381 772.88882 432.21373 773.97874 433.55367 773.97874 C
434.89389 773.97874 435.98381 772.88882 435.98381 771.54888 C
435.98381 770.19874 434.89389 769.11874 433.55367 769.11874 C
@c
S

@rax %Note: Object
437.35691 52.96819 441.77669 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
439.56680 52.96819 m
438.34677 52.96819 437.35691 53.95805 437.35691 55.17808 C
437.35691 56.39811 438.34677 57.39817 439.56680 57.39817 C
440.78683 57.39817 441.77669 56.39811 441.77669 55.17808 C
441.77669 53.95805 440.78683 52.96819 439.56680 52.96819 C
@c
S

@rax %Note: Object
437.23389 769.11874 442.09389 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
439.66375 769.11874 m
438.32381 769.11874 437.23389 770.19874 437.23389 771.54888 C
437.23389 772.88882 438.32381 773.97874 439.66375 773.97874 C
441.00369 773.97874 442.09389 772.88882 442.09389 771.54888 C
442.09389 770.19874 441.00369 769.11874 439.66375 769.11874 C
@c
S

@rax %Note: Object
443.43694 52.96819 447.86693 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
445.65676 52.96819 m
444.43672 52.96819 443.43694 53.95805 443.43694 55.17808 C
443.43694 56.39811 444.43672 57.39817 445.65676 57.39817 C
446.87679 57.39817 447.86693 56.39811 447.86693 55.17808 C
447.86693 53.95805 446.87679 52.96819 445.65676 52.96819 C
@c
S

@rax %Note: Object
443.22378 769.11874 448.08378 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
445.65392 769.11874 m
444.31370 769.11874 443.22378 770.19874 443.22378 771.54888 C
443.22378 772.88882 444.31370 773.97874 445.65392 773.97874 C
446.99386 773.97874 448.08378 772.88882 448.08378 771.54888 C
448.08378 770.19874 446.99386 769.11874 445.65392 769.11874 C
@c
S

@rax %Note: Object
449.53682 52.96819 453.96680 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
451.74784 52.96819 m
450.52668 52.96819 449.53682 53.95805 449.53682 55.17808 C
449.53682 56.39811 450.52668 57.39817 451.74784 57.39817 C
452.96674 57.39817 453.96680 56.39811 453.96680 55.17808 C
453.96680 53.95805 452.96674 52.96819 451.74784 52.96819 C
@c
S

@rax %Note: Object
449.24372 769.11874 454.10372 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
451.67386 769.11874 m
450.33392 769.11874 449.24372 770.19874 449.24372 771.54888 C
449.24372 772.88882 450.33392 773.97874 451.67386 773.97874 C
453.01380 773.97874 454.10372 772.88882 454.10372 771.54888 C
454.10372 770.19874 453.01380 769.11874 451.67386 769.11874 C
@c
S

@rax %Note: Object
455.53691 52.96819 459.96690 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
457.74794 52.96819 m
456.52677 52.96819 455.53691 53.95805 455.53691 55.17808 C
455.53691 56.39811 456.52677 57.39817 457.74794 57.39817 C
458.96683 57.39817 459.96690 56.39811 459.96690 55.17808 C
459.96690 53.95805 458.96683 52.96819 457.74794 52.96819 C
@c
S

@rax %Note: Object
455.20384 769.11874 460.06384 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
457.63370 769.11874 m
456.29376 769.11874 455.20384 770.19874 455.20384 771.54888 C
455.20384 772.88882 456.29376 773.97874 457.63370 773.97874 C
458.97392 773.97874 460.06384 772.88882 460.06384 771.54888 C
460.06384 770.19874 458.97392 769.11874 457.63370 769.11874 C
@c
S

@rax %Note: Object
461.40690 52.96819 465.83688 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
463.62671 52.96819 m
462.39676 52.96819 461.40690 53.95805 461.40690 55.17808 C
461.40690 56.39811 462.39676 57.39817 463.62671 57.39817 C
464.84674 57.39817 465.83688 56.39811 465.83688 55.17808 C
465.83688 53.95805 464.84674 52.96819 463.62671 52.96819 C
@c
S

@rax %Note: Object
461.31392 769.11874 466.17392 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
463.74378 769.11874 m
462.40384 769.11874 461.31392 770.19874 461.31392 771.54888 C
461.31392 772.88882 462.40384 773.97874 463.74378 773.97874 C
465.09392 773.97874 466.17392 772.88882 466.17392 771.54888 C
466.17392 770.19874 465.09392 769.11874 463.74378 769.11874 C
@c
S

@rax %Note: Object
467.43676 52.96819 471.86674 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
469.65685 52.96819 m
468.43682 52.96819 467.43676 53.95805 467.43676 55.17808 C
467.43676 56.39811 468.43682 57.39817 469.65685 57.39817 C
470.87688 57.39817 471.86674 56.39811 471.86674 55.17808 C
471.86674 53.95805 470.87688 52.96819 469.65685 52.96819 C
@c
S

@rax %Note: Object
467.31373 769.11874 472.17373 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
469.74387 769.11874 m
468.40394 769.11874 467.31373 770.19874 467.31373 771.54888 C
467.31373 772.88882 468.40394 773.97874 469.74387 773.97874 C
471.09373 773.97874 472.17373 772.88882 472.17373 771.54888 C
472.17373 770.19874 471.09373 769.11874 469.74387 769.11874 C
@c
S

@rax %Note: Object
473.40680 52.96819 477.83679 57.39817 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
475.62690 52.96819 m
474.39694 52.96819 473.40680 53.95805 473.40680 55.17808 C
473.40680 56.39811 474.39694 57.39817 475.62690 57.39817 C
476.84693 57.39817 477.83679 56.39811 477.83679 55.17808 C
477.83679 53.95805 476.84693 52.96819 475.62690 52.96819 C
@c
S

@rax %Note: Object
473.37392 769.11874 478.23392 773.97874 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
475.80378 769.11874 m
474.45392 769.11874 473.37392 770.19874 473.37392 771.54888 C
473.37392 772.88882 474.45392 773.97874 475.80378 773.97874 C
477.14372 773.97874 478.23392 772.88882 478.23392 771.54888 C
478.23392 770.19874 477.14372 769.11874 475.80378 769.11874 C
@c
S

@rax %Note: Object
562.72082 411.52224 566.78088 415.76202 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
564.75071 415.76202 m
565.87068 415.76202 566.78088 414.81213 566.78088 413.64198 C
566.78088 412.47213 565.87068 411.52224 564.75071 411.52224 C
563.63074 411.52224 562.72082 412.47213 562.72082 413.64198 C
562.72082 414.81213 563.63074 415.76202 564.75071 415.76202 C
@c
S

@rax %Note: Object
71.74800 712.86576 101.95597 743.07373 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
86.85213 743.07373 m
78.51005 743.07373 71.74800 736.31282 71.74800 727.97074 C
71.74800 719.62894 78.51005 712.86576 86.85213 712.86576 C
95.19420 712.86576 101.95597 719.62894 101.95597 727.97074 C
101.95597 736.31282 95.19420 743.07373 86.85213 743.07373 C
@c
S

@rax %Note: Object
78.80315 719.91978 94.90195 736.02085 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 0.56693 0.56693 0.00000 @w
86.85213 719.91978 m
82.40598 719.91978 78.80315 723.52375 78.80315 727.97074 C
78.80315 732.41575 82.40598 736.02085 86.85213 736.02085 C
91.29798 736.02085 94.90195 732.41575 94.90195 727.97074 C
94.90195 723.52375 91.29798 719.91978 86.85213 719.91978 C
@c
S

 @gs spg @gr
%%PageTrailer
@rs
@rs
%%Trailer
@EndSysCorelDict
end
%%DocumentSuppliedResources: procset wCorel21Dict 21.0 0
%%EOF
