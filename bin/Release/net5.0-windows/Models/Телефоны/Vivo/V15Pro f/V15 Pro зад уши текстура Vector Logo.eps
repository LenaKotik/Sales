%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 67 323 302 806 
%%LanguageLevel: 2
%%Creator: CorelDRAW
%%Title: V15 Pro зад уши текстура Vect...
%%CreationDate: Wed Jul 31 11:40:22 2019
%%DocumentProcessColors: Cyan Magenta Yellow Black 
%%DocumentSuppliedResources: (atend)
%%EndComments
%%BeginProlog
/AutoFlatness false def
/AutoSteps 0 def
/CMYKMarks true def
/DocPsLevel 2 def
%Build: CorelDRAW Версия 21.2.0.708
/EpsFile true def
%%BeginResource: procset wCorel21Dict 21.0 0
/wCorel21Dict 300 dict def wCorel21Dict begin
%----------------------------------------------------------------------------
% Core Corel PostScript prolog functions
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
% Reduced syntax procedures
%----------------------------------------------------------------------------

/bd {bind def} bind def      				% bind proc names to current proc reference in the dict and define
/ld {load def} bd            				% load operator and define
/xd {exch def} bd            				% exchange operators on stack and define
/rp { {pop} repeat } bd      				% pop entries off stack iNumToPop rp
/dexec { exch begin cvx exec end } bd	% executes procedure from the dictionary on stack
/@cp /closepath ld
/@gs /gsave ld
/@gr /grestore ld
/@np /newpath ld
/Tl /translate ld
/$sv 0 def                   				% graphic state save snapshots
/@sv {/$sv save def}bd
/@rs {$sv restore}bd

/spg /showpage ld
/showpage {} bd

currentscreen                	% establish document's default halftone screen
/@dsp xd                     	% default spot func
/$dsp /@dsp def              	% default spot func name
/$dsa xd                     	% default screen angle
/$dsf xd                     	% default screen frequency function
/$sdf false def              	% FLAG: non-default screen for fill (true)
/$SDF false def              	% FLAG: non-default screen for stroke (true)
/$Scra 0 def                 	% screen adjustment (-90 if printing landscape)

/SetScr /setscreen ld					% sub in out own setscreen operator

/@ss                         	% Set Screen angle account for adjustment
{                            	% frequency angle proc
 2 index 0 eq
 {
  $dsf 3 1 roll              	% frequency angle proc deffreq
  4 -1 roll pop              	%
 } if                        	%
 exch $Scra add exch load    	% frequency angle+$Scra {proc}
 SetScr                   		%
} bd                         	%

/SeparationMode where					% init separatin mode
{ pop }{ /SeparationMode /Composite def } ifelse

/SeparationPlateName where		% init separation plate name
{ pop }{ /SeparationPlateName null def } ifelse

/SeparateInColor where				% init separtion in color flag
{ pop }{ /SeparateInColor false def	} ifelse


/EpsFile where								% are we an EPS file
{pop}
{/EpsFile false def} ifelse

/FillOverprint false def    % Fill overprint flag
/$fil 0 def                 % Fill type: 0:solid 1:pattern 2:fountain 3:PS 4:fountain shfill

/OutlineOverprint 0 def     % Outline overprint flag
/$PF false def              % pattern stroke flag(0 no pattern, 1 pattern)

/$bkg false def             % imaging background only flag
/CurrentOverprint false def % overprint flag

matrix currentmatrix        % establish current matrix
/$ctm xd                    % initial general transfo matrix

/$ptm matrix def            % pen stroking matrix(defaults identity)
/$ttm matrix def            % text transfo matrix(Corel extensions)
/$stm matrix def            % "save" matrix in extended text(Corel extensions)

/$ffpnt true def						% flag for painting fountain strips (overprint prob)

%----------------------------------------------------------------------------
% Corel re-encoding vector
%----------------------------------------------------------------------------
/CorelDrawReencodeVect [
16#0/grave 16#5/breve 16#6/dotaccent 16#8/ring 16#A/hungarumlaut 16#B/ogonek 16#C/caron
16#D/dotlessi 16#27/quotesingle 16#60/grave 16#7C/bar 16#80/Euro
16#82/quotesinglbase/florin/quotedblbase/ellipsis/dagger/daggerdbl
16#88/circumflex/perthousand/Scaron/guilsinglleft/OE
16#91/quoteleft/quoteright/quotedblleft/quotedblright/bullet/endash/emdash
16#98/tilde/trademark/scaron/guilsinglright/oe
16#9F/Ydieresis
16#A1/exclamdown/cent/sterling/currency/yen/brokenbar/section
16#a8/dieresis/copyright/ordfeminine/guillemotleft/logicalnot/minus/registered/macron
16#b0/degree/plusminus/twosuperior/threesuperior/acute/mu/paragraph/periodcentered
16#b8/cedilla/onesuperior/ordmasculine/guillemotright/onequarter/onehalf/threequarters/questiondown
16#c0/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
16#c8/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis
16#d0/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis/multiply
16#d8/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute/Thorn/germandbls
16#e0/agrave/aacute/acircumflex/atilde/adieresis/aring/ae/ccedilla
16#e8/egrave/eacute/ecircumflex/edieresis/igrave/iacute/icircumflex/idieresis
16#f0/eth/ntilde/ograve/oacute/ocircumflex/otilde/odieresis/divide
16#f8/oslash/ugrave/uacute/ucircumflex/udieresis/yacute/thorn/ydieresis
] def

%----------------------------------------------------------------------------
% Proc:  get_ps_level
% Stack: get_ps_level pslevel
% Desc:  returns level of PS interpreter environemnt
%----------------------------------------------------------------------------
/get_ps_level
	/languagelevel where
	{
		pop systemdict /languagelevel get exec
	}
	{
		1
	} ifelse
def

%----------------------------------------------------------------------------
% Level 2 or 3 flag
%----------------------------------------------------------------------------
/Level2 get_ps_level 2 ge def

%----------------------------------------------------------------------------
% Level 3 flag
%----------------------------------------------------------------------------
/Level3 get_ps_level 3 ge def

%----------------------------------------------------------------------------
% Flag to indicate we are processed by AdobeDistiller
%----------------------------------------------------------------------------
/AdobeDistiller
  /product where
  {
    pop systemdict/setdistillerparams known product (Adobe PostScript Parser) ne and
  }
  {
    false
  }ifelse
def

%----------------------------------------------------------------------------
% Flag to indicate we are are being separated in-RIP (not by Distiller!)
%----------------------------------------------------------------------------
/InRipSeparation
  AdobeDistiller
  {
    false										% we are being distilled by Adobe Distiller, not RIP
  }
  {
    Level2									% in-RIP separations allowed for Level2 and higher
    {
      currentpagedevice/Separations 2 copy known		% check currentpage dict - Separations should be set true
      {
        get
      }
      {
        pop pop false
      }ifelse
    }
    {
     false
    }ifelse
  }	ifelse
def

%----------------------------------------------------------------------------
% Flag to indicate we are being separated through overloaded
% setcmykcolor/currentcmykcolor operators, Level 1 style
%----------------------------------------------------------------------------
/ColorSeparationLevel1

	% try to set pure Cyan, Magenta, Yellow and Black colors and see whether system knock one of the colors

	1 0 0 0 gsave setcmykcolor currentcmykcolor grestore add add add 0 ne
	0 1 0 0 gsave setcmykcolor currentcmykcolor grestore add add add 0 ne
	0 0 1 0 gsave setcmykcolor currentcmykcolor grestore add add add 0 ne
	0 0 0 1 gsave setcmykcolor currentcmykcolor grestore add add add 0 ne
	and and and not
def

%----------------------------------------------------------------------------
% Flag to indicate we are being separated (does not matter by which method)
%----------------------------------------------------------------------------
/ColorSeparation
  /LumSepsDict where            % see if we're being separated by TrapWise or PressWise
  {
    pop                         % lose the dictionary
    false                       % return false
  }
  {
    /AldusSepsDict where        % they might also use this one (Mac vs. PC?)
    {
      pop                       % lose the dictionary
      false                     % return false
    }
    {                           % we're not being separated by TrapWise or PressWise, use a generic method
      InRipSeparation						% is in-RIP (Level2 style) separation
      {
        true
      }
      {
        % is Level 1 style separation, through overloaded setcmykcolor currentcmykcolor operators
		ColorSeparationLevel1
      }ifelse
    }ifelse
  }ifelse
def

%----------------------------------------------------------------------------
% Flag to indicate that PS device has color capabilities
%----------------------------------------------------------------------------
/IsColorDevice
	/deviceinfo where
	{
		pop deviceinfo /Colors known
		{
			deviceinfo /Colors get exec 1 gt
		}
		{
			false
		}ifelse
	}
	{
		/statusdict where
		{
			pop statusdict /processcolors known
			{
				statusdict /processcolors get exec 1 gt
			}
			{
				false
			}ifelse
		}
		{
			false
		}ifelse
	} ifelse
def

%----------------------------------------------------------------------------
% Proc:		get_simulate_devicen
% Stack:	--> get_simulate_devicen --> bool
%					bool true - smiluate DeviceN through overprinting on Level 2
% Desc:		determines if we should simulate DeviceN colors through overprints thus
%					preserving spot colors on Level 2 devices in composite mode
%----------------------------------------------------------------------------
/get_simulate_devicen
  get_ps_level 2 eq							% we simulate DeviceN only on Level2
  {
    {
			SeparationMode /OnHost ne								% no DeviceN simulation for on-host separations mode
			InRipSeparation AdobeDistiller or and		% do it for in-RIP separation or distilling
    } bind
  }
  {
    false
  }ifelse
def

%----------------------------------------------------------------------------
%
%	Color objects definition section
%
%----------------------------------------------------------------------------

% Default document colorspaces
/DocGrayScaleSpace [/DeviceGray] def
/DocRgbSpace [/DeviceRGB] def
/DocCmykSpace [/DeviceCMYK] def

/DocLabSpace
[
	/CIEBasedABC
	<<
	/BlackPoint [0 0 0]
	/WhitePoint [ 0.9637  1.0000  0.8241 ]
	/RangeABC [0 100 -128 127 -128 127]
	/DecodeABC [{16 add 116 div} bind {500 div} bind {200 div} bind]
	/MatrixABC [1 1 1 1 0 0 0 0 -1]
	/DecodeLMN
	[
		{dup 0.206897 ge{dup dup mul mul}{0.137931 sub 0.128419 mul} ifelse  0.9637 mul }bind 
		{dup 0.206897 ge{dup dup mul mul}{0.137931 sub 0.128419 mul} ifelse  1.0000 mul }bind 
		{dup 0.206897 ge{dup dup mul mul}{0.137931 sub 0.128419 mul} ifelse  0.8241 mul }bind 
	]
	>>
] def

%----------------------------------------------------------------------------
% Proc:		validate_cie_colorspace_whitepoint
% Stack: 	colorspacedict --> validate_cie_colorspace_whitepoint --> colorspacedict
% Desc: 	validates CIE colorspace white point, the Yw parameter must be 1.0
%----------------------------------------------------------------------------
/validate_cie_colorspace_whitepoint
{
	load dup aload pop
	/WhitePoint get
	1 1.0 put pop
} bd

%----------------------------------------------------------------------------
% Proc:		set_cie_colorspaces
% Stack: 	none
% Desc: 	sets document color spaces to the CIE CSA, if exist
%----------------------------------------------------------------------------
/set_cie_colorspaces
{
	/DocGrayScaleSpaceCIE where
	{
		pop
		/DocGrayScaleSpaceCIE validate_cie_colorspace_whitepoint /DocGrayScaleSpace xd
		
		% modify CIEBasedA definition for /DecodeA key written by ICM
		% it is an array while should be a procedure, PS interpreters will fail otherwise
		DocGrayScaleSpace aload pop
		begin pop
			/DecodeA where
			{
				pop
				DecodeA type /arraytype eq
				{
					DecodeA aload pop
					/DecodeA exch def			
				}if
			}if
		end
	}if

	/DocRgbSpaceCIE where
	{	
		pop
		/DocRgbSpaceCIE validate_cie_colorspace_whitepoint /DocRgbSpace xd
	}if

	/DocCmykSpaceCIE where
	{
		pop
		/DocCmykSpaceCIE validate_cie_colorspace_whitepoint /DocCmykSpace xd
	}if
} bd

%----------------------------------------------------------------------------
% Proc:		set_rendering_intent
% Stack: 	rendering_intent set_rendering_intent
%			rendering_intent - either /Perceptual, /AbsoluteColorimetric,
%			/RelativeColormetric or /Saturation
% Desc: 	sets prefered rendring intent to use in CRD on device
%----------------------------------------------------------------------------
/set_rendering_intent
{
	Level3
	{
		findcolorrendering
		{
			% CRD found for requested rendering intent and device settings
			/ColorRendering findresource setcolorrendering 
		}
		{
			% CRD not found for requested rendering intent
			dup /DefaultColorRendering eq
			{ 
				pop
			}
			{
				/ColorRendering findresource setcolorrendering 
			}
		}ifelse 
	}
	{
		pop
	}ifelse
} bd

%----------------------------------------------------------------------------
% Proc:	findcmykcustomcolor
% Stack: 	c m y k name --> findcmykcustomcolor --> array
%				c - cyan color component
%				m - magenta color component
%				y - yellow color component
%				k - black color component
%				(name) - spot color name
% Desc: 	finds spot color object defined by the name, if no fyndcmykcutomcolor
%				is defined on the system  just stores alternative CMYK values and name
%				in the array to be used by setcustomcolor procedure
%----------------------------------------------------------------------------
/findcmykcustomcolor where
{
  pop
}
{
  /findcmykcustomcolor
  {
    5 array astore
  } def
} ifelse

%----------------------------------------------------------------------------
% Proc:	setcustomcolor
% Stack: 	array tint --> setcustomcolor
%				array - color array returned by findcmykcustomcolor
%				tint - color component value
% Desc: 	sets custom ink ( spot ) color or its alternative CMYK representation
%				if spot color is not available on the system (printer/RIP)
%----------------------------------------------------------------------------
/setcustomcolor where
SeparationMode /OnHost ne and
{
  pop
}
{
	%----------------------------------------------------------------------------
	% Stack: 	tint cyan magenta yellow black tint_cmyk_color cyan1 magenta1 yellow1 black1
	% Desc: 	tint color
	%----------------------------------------------------------------------------
	/tint_cmyk_color
	{
		 5 -1 roll
		 dup 1 ge                    	% see if tint >= 1
		 {pop}                       	% if it is, pop it
		 {                           	% otherwise, multiply all 4 components
			4
			{
				dup                   	% duplicate the tint
				6 -1 roll              	% get next component
				mul                    	% multiply with current tint
				exch                    % tint back on top
			}repeat
			pop                        	% no need for tint anymore
		 } ifelse
	} bd  
  
	%----------------------------------------------------------------------------
	% Stack: 	c m y k setprocesscolor_5 -
	% Desc: 	sets process color without doing any separations
	%			we assume color has been preseparated
	%----------------------------------------------------------------------------
	/setprocesscolor_5
	{
		SepMode_5 0 eq              % Check if not performing color seps.
		{
			SetCmyk_5               % set CMYK color
		}
		{
			SepsColor not         	% separating in grayscale
   			{
				4 1 roll pop pop pop	% leave just K component on stack
				1 exch sub SetGry		%	set gray component		
			}
			{
				SetCmyk_5               % set CMYK color for separations in color
			}ifelse
		}ifelse
	} bd	
  
	/setcustomcolor
	{
  		exch
    	aload pop
    	SepMode_5 0 eq
    	{
     		pop
     		tint_cmyk_color
     		setprocesscolor_5
    	}
    	{
     		CurrentInkName_5 eq
     		{
      			4 index
     		}
     		{
      			0
     		}ifelse
     		6 1 roll
     		5 rp
     		1 sub neg SetGry
    	}ifelse
   } bd 

} ifelse

%----------------------------------------------------------------------------
% Proc:		convert_rgb_to_cmyk
% Stack: 	r g b ConvDict convert_rgb_to_cmyk c m y k
%					r - red
%					g - green
%					b - blue
%					ConvDict - conversion dictionary with RGB-CMYK look up table (LUT)
%					c - cyan
%					m - magenta
%					y - yellow
%					k - black
% Desc: 	converts rgb color values to cmyk color values using either RGB-to-CMYK
%					look up table	if supplied, or primitive conversion formulae
%----------------------------------------------------------------------------
/convert_rgb_to_cmyk
{
 dup type /dicttype eq
 {
 }
 {
  3                         %
  {                         % r g b
    1 exch sub              % r g 1-b       	% y = 1 - b
    3 1 roll                % y r g
  } repeat                  % c m y
  3 copy                    % c m y c m y
  min min                   % c m y min(c,m,y)     	% K=min(c,m,y)
  3                         %
  {                         % c m y K
    dup 5 -1 roll           % m y K K c
    sub neg                 % m y K c-K     	% C = c - K
    exch                    % m y C K
  } repeat                  % C M Y K
 } ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		colorspace safe_setcolorspace
% Stack: 	colorspace --> safe_setcolorspace -->
% 				colorspace colorspace to set
% Desc: 	set colorspace, unless it is already current colorspace
%----------------------------------------------------------------------------
/safe_setcolorspace
{
  dup
  currentcolorspace eq
  {
    pop
  }
  {
    setcolorspace

  }ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		safe_setoverprint
% Stack:	overprintflag safe_setoverprint
%					overprintflag - boolean or integer
% Desc:		sets current color performing separations if necessary
%----------------------------------------------------------------------------
/safe_setoverprint
{
	dup type /booleantype eq			% boolean flag is passed
  {
    dup
    currentoverprint ne
    {
			setoverprint
		}
    {
			pop
		}
    ifelse
  }
  {															% integer flag is passed
		1 eq setoverprint
	}
  ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		is_cmyk_channel_name
% Stack: 	channelName --> is_cmyk_channel_name --> bool
%			channelName - name of the channel
% Desc: 	determines whether channel name on stack belong to cmyk color
%----------------------------------------------------------------------------
/is_cmyk_channel_name
{
	/channel_name xd

	channel_name /Cyan eq
	channel_name /Magenta eq or
	channel_name /Yellow eq or
	channel_name /Black eq or
	{
		true		
	}
	{
		false
	}ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		is_rgb_channel_name
% Stack: 	channelName --> is_rgb_channel_name --> bool
%			channelName - name of the channel
% Desc: 	determines whether channel name on stack belong to RGB color
%----------------------------------------------------------------------------
/is_rgb_channel_name
{
	/channel_name xd

	channel_name /Red eq
	channel_name /Green eq or
	channel_name /Blue eq or
	{
		true		
	}
	{
		false
	}ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		is_spot_channel_name
% Stack: 	channelName --> is_spot_channel_name --> bool
%			channelName - name of the channel
% Desc: 	determines whether channel name on stack belong to spot color
%----------------------------------------------------------------------------
/is_spot_channel_name
{
	/channel_name xd

	channel_name is_cmyk_channel_name
	channel_name is_rgb_channel_name or
	channel_name /Gray eq or
	{
		false		
	}
	{
		true
	}ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		spot_tint_transform_proc
% Stack: 	tint  [ alternativeColors ] alternativeSpace --> spot_tint_transform_proc -- > tinted spot color in alternative color space
%			alternativeSpace - alternative color space ( e.g. /DocGrayScaleSpace, /DocRgbSpace, /DocCmykSpace )
%			[ alternative color values ] - spot color values in alternative color space
%			tint - tint of spot color [ 0.. 1.0]
% Desc: 	applies tint to spot ink's alternative color space values
%----------------------------------------------------------------------------
/spot_tint_transform_proc
{
	/alternativeSpace xd
	/alternativeColors xd
	/tint xd
	
	alternativeSpace DocLabSpace eq
	{
		/mixMethod /Additive def
		/altSpaceNumChannels 3 def
	}
	{
	  alternativeSpace DocCmykSpace eq
	  {
		/mixMethod /Subtractive def
		/altSpaceNumChannels 4 def
	  }
	  {
		alternativeSpace DocRgbSpace eq
		{
		  /mixMethod /Additive def
		  /altSpaceNumChannels 3 def
		}
		{
		  alternativeSpace DocGrayScaleSpace eq
		  {
			/mixMethod /Additive def
			/altSpaceNumChannels 1 def
		  } if
		} ifelse
	  }ifelse
	}ifelse

  	% apply tint on spot's alt color values

  	alternativeSpace DocLabSpace eq
	{
		% for LAB tint just colorant values, leave lightness alone
		alternativeColors aload pop
		tint mul 3 1 roll
		tint mul 3 1 roll
		dup 100 exch sub 1 tint sub mul add 3 1 roll
	}
	{
  		/tintedColor altSpaceNumChannels {0.0} repeat altSpaceNumChannels array astore def
		
		0 1 altSpaceNumChannels 1 sub
		{
			/altChannelIndex exch def
			
			alternativeColors altChannelIndex get
			
			% tint every channel
			mixMethod /Additive eq
			{
				1.0 exch sub tint mul
				1.0 exch sub
			}
			{
				tint mul
			}ifelse
			
			tintedColor altChannelIndex 3 2 roll put
		}for
		
		tintedColor aload pop
	}ifelse
  
} bd

%----------------------------------------------------------------------------
% Proc:	devicen_colorant_mixer_proc
% Stack: 	colorant1... colorantN  [ alternativeColor ] [names] alternativeSpace  N --> colorant_mixer_proc -- > mixedColor
%			N - number of colorants
%			alternativeSpace - alternative color space ( e.g. /DocGrayScaleSpace, /DocRgbSpace, /DocCmykSpace )
%			colorant i - colorant values
%			alternativeColor N - colorant representation in alternative colorspace
%			names N - alternative color plate names
%			mixedColor - mixed color in alternativeColorspace
% Desc: 	mixes colorants to produce color representation in alternative color space
%----------------------------------------------------------------------------
/devicen_colorant_mixer_proc
{
	/numChannels xd
	/alternativeSpace xd
	/channelNames xd
	/alternativeColors xd
	numColorants array astore /colorants xd

	/is_spot_channel_name_loc { is_spot_channel_name } bind def
	
	alternativeSpace DocCmykSpace eq
	{
		/mixMethod /Subtractive def
		/altSpaceNumChannels 4 def
		/is_spot_channel_name_loc { is_cmyk_channel_name not } bind def
	}
	{
		alternativeSpace DocRgbSpace eq
		{
			/mixMethod /Additive def
			/altSpaceNumChannels 3 def
			/is_spot_channel_name_loc { is_rgb_channel_name not } bind def
		}
		{
			alternativeSpace DocGrayScaleSpace eq
			{
				/mixMethod /Additive def
				/altSpaceNumChannels 1 def
				/is_spot_channel_name_loc { /Gray ne } bind def
			} if
		} ifelse
	}ifelse

  % iterate over all components of alternative color space
  mixMethod /Additive eq
  {
	/mixedColor altSpaceNumChannels {0.0} repeat altSpaceNumChannels array astore def

	/bProcessPlateTinted false def
	
	0 1 numChannels 1 sub
	{
		/channelIndex exch def

		channelNames channelIndex get is_spot_channel_name_loc
		/bSpotChannel xd	
		/sourceChannel colorants channelIndex get def								% colorant [channelIndex]
		
		/bWhiteBackground
			0 mixedColor {add} forall
			altSpaceNumChannels div
			0.999 gt bProcessPlateTinted and
		def
		
		bSpotChannel bProcessPlateTinted not and
		{
			/bSpotChannel false def
		}if
		
		0 1 altSpaceNumChannels 1 sub
		{
			/altChannelIndex exch def
			/mixedChannel mixedColor altChannelIndex get def

			sourceChannel
			alternativeColors channelIndex get altChannelIndex get 	% alternativeColor[channelIndex][altChannelIndex]
			1.0 exch sub mul
			1.0 exch sub
		
			dup 1.0 gt { pop 1.0 }if
			dup 0.0 lt { pop 0.0 }if
			
			bSpotChannel
			{
				sourceChannel 0.0 gt
				{
					% paints area covered by spot
					mixedChannel mul
				}
				{
					% paints area not covered by spot ink
					pop mixedChannel
				}ifelse
			}
			{
				/bProcessPlateTinted true def

				globaldict begin
					/bSkipDeviceNImage where
					{
						pop false
					}
					{
						true
					}
					ifelse
				end
				
				DevicenImage and
				{
					pop

					sourceChannel
					alternativeColors channelIndex get altChannelIndex get 	% alternativeColor[channelIndex][altChannelIndex]
					mul
					
					mixedChannel add
				}
				{
					mixedChannel add
				}ifelse
			}ifelse
			
			dup 1.0 gt { pop 1.0 }if
			dup 0.0 lt { pop 0.0 }if
			mixedColor altChannelIndex 3 2 roll put
		}for
	}for
  }
  {
	/mixedColor altSpaceNumChannels {1} repeat altSpaceNumChannels array astore def

	0 1 altSpaceNumChannels 1 sub
	{
		/targetIndex exch def

		% iterate over all colorants of original colorspace
		0 1 numColorants 1 sub
		{
		  /sourceIndex exch def
		  colorants sourceIndex get								%  colorant [sourceIndex]
		  alternativeColors sourceIndex get targetIndex get 	% alternativeColor[sourceIndex][targetIndex]

		  mul
		  1 exch sub

		  mixedColor targetIndex get mul mixedColor targetIndex 3 2 roll put
		} for

		mixedColor targetIndex 1 mixedColor targetIndex get sub put
		
	} for
  } ifelse

  mixedColor aload pop
} bd


%----------------------------------------------------------------------------
% Colorspec dictionary definition
% Grayscale, RGB, HSB, CMYK, Lab, Spot, DeviceN and Registration color dictionaries
% are created by replicating and extending abstract ColorSpec dictionary
%----------------------------------------------------------------------------
/ColorSpec
  9 dict begin
		/color [] def					% color component values
		/names [] def					% color components names - reserved : (Cyan ) (Magenta) (Yellow) (Black) (Red) (Green) (Blue) (All)
		/num 0 def						% number of color components/names
		/ColorModel	null def	% color model : /Grayscale /Rgb /Cmyk /Spot /DeviceN /Registration
		/ColorSpace [] def		% CSA or device colorspace array

		%----------------------------------------------------------------------------
		% Stack: 	--> set_color -->
		% Desc: 	sets color as current
		%----------------------------------------------------------------------------
		/set_color
		{
			ColorSeparationLevel1
			{
				convert_to_cmyk /color get aload pop setcmykcolor
			}
			{
				ColorSpace safe_setcolorspace
				color aload pop setcolor
			}
			ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_set_color --> bool
		%					bool - painting flag : true - paint, false - do not paint
		% Desc: 	separates color, if necessary, and sets as current. Painting
		%					flag is set according whether separation to current plate happened
		%					and overprint settings
		%----------------------------------------------------------------------------
		/separate_set_color
		{
			SeparationMode /OnHost eq
			{
				separate_color
				{
				 /set_color dexec true
				}
				{
					pop							% remove colorspec on stack
					currentoverprint
					{
						false					% overprint flag is on, do not knockout
					}
					{
						% overprint flag is off, knockout
						SeparateInColor
						{
							% knockout - paint white CMYK object
							0 0 0 0 SetCmyk_5 true
						}
						{
							% knockout - paint white grayscale object
							1 SetGry true
						} ifelse
					} ifelse
				} ifelse
			}
			{
				set_color true
			} ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color	{ currentdict false } bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk { currentdict } bd

	currentdict end
def

%----------------------------------------------------------------------------
% Grayscale color dictionary definition
%----------------------------------------------------------------------------
/GrayscaleColorSpec
	ColorSpec 9 dict copy
  begin
		/names {/Black} def									% color components names
		/num 1 def													% number of color components/names
		/ColorModel	/Grayscale def					% color model
		/ColorSpace DocGrayScaleSpace def		% CSA or device colorspace array

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			currentdict false

			SeparationMode /OnHost eq
			{
				SeparationPlateName /Black eq
				{
					SeparateInColor
					{
						pop convert_to_cmyk true
					}
					{
						pop true
					} ifelse
				}if
			}if
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			0 0 0 color aload pop 1 exch sub create_cmyk_color
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_grayscale_color
% Stack: 	tint --> create_grayscale_color -- >colorspec
%				tint - gray component value
%				colorspec - colorspec dicitonary
% Desc: 	creates grayscale color dictionary
%----------------------------------------------------------------------------
/create_grayscale_color
{
	GrayscaleColorSpec 9 dict copy
	begin
		/color exch 1 array astore def			% color component values
		/ColorSpace DocGrayScaleSpace def		% document Grayscale color space 	
	currentdict end
} bd

%----------------------------------------------------------------------------
% RGB color dictionary definition
%----------------------------------------------------------------------------
/RgbColorSpec
	ColorSpec 9 dict copy
  begin
    /names {/Red /Green /Blue} def		% color components names
    /num 3 def												% number of color components/names
		/ColorModel	/Rgb def							% color model
    /ColorSpace DocRgbSpace def				% CSA or device colorspace array

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			convert_to_cmyk /separate_color dexec
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			color aload pop convert_rgb_to_cmyk create_cmyk_color
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_rgb_color
% Stack: 	r g b --> create_rgb_color -- >colorspec
%				r, g, b - Red, Green, Blue color components respectively
%				colorspec - colorspec dicitonary
% Desc: 	creates RGB color dictionary
%----------------------------------------------------------------------------
/create_rgb_color
{
	RgbColorSpec 9 dict copy
	begin
		3 array astore /color exch def		% color component values
		/ColorSpace DocRgbSpace def			% document RGB color space 	
	currentdict end
} bd

%----------------------------------------------------------------------------
% HSB color dictionary definition
% HSB is a math transform of RGB color model and is represented by RGB color space
%----------------------------------------------------------------------------
/HsbColorSpec
	ColorSpec 9 dict copy
  begin
    /names {/Hue /Saturation /Brightness} def		% color components names
    /num 3 def												% number of color components/names
		/ColorModel	/Hsb def							% color model
    /ColorSpace DocRgbSpace def				% CSA or device colorspace array

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			convert_to_cmyk /separate_color dexec
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			color aload pop
			hsb2rgb
			convert_rgb_to_cmyk create_cmyk_color
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_rgb --> colorspec
		% Desc: 	converts current colorspec to RGB colorspec
		%----------------------------------------------------------------------------
		/convert_to_rgb
		{
			color aload pop
			hsb2rgb
			create_rgb_color
		} bd

	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_hsb_color
% Stack: 	h s b --> create_hsb_color -- >colorspec
%				h, s, b - Hue, Saturation, Brightness color components respectively
%				colorspec - colorspec dicitonary
% Desc: 	creates HSB color dictionary
%----------------------------------------------------------------------------
/create_hsb_color
{
	HsbColorSpec 9 dict copy
	begin
		3 array astore /color exch def		% color component values
		/ColorSpace DocRgbSpace def				% document RGB color space 	
	currentdict end
} bd

%----------------------------------------------------------------------------
% CMYK color dictionary definition
%----------------------------------------------------------------------------
/CmykColorSpec
  ColorSpec 9 dict copy													% copy colorspec
  begin
    /names {/Cyan /Magenta /Yellow /Black} def	% color components names
    /num 4 def																	% number of color components/names
 		/ColorModel	/Cmyk def												% color model
    /ColorSpace DocCmykSpace def								% CSA or device colorspace array

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			currentdict false

			SeparationPlateIndex 0 ge
			SeparationPlateIndex 3 le and
			{
				color SeparationPlateIndex get	% get tint on current separation plate

				dup 0 gt
				{
					3 1 roll pop pop
					% tint on current plate is not zero - have separation
					SeparateInColor
					{
						% move tint to SeparationPlateIndex position in CMYK color
						% so for example Cyan plate will print in pure cyan CMYK
						% color instead of default grayscale

						0 0 0 4 SeparationPlateIndex roll create_cmyk_color true
					}
					{
						% separate to grayscale color
						1 exch sub create_grayscale_color true
					} ifelse
				}
				{
					pop
				} ifelse
			} if
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			% it is CMYK already, return current colorspec
			currentdict
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_cmyk_color
% Stack: 	c m y k --> create_cmyk_color -- >colorspec
%				c, m, y, k - Cyan, Magenta, Yellow and Black color components respectively
%				colorspec - colorspec dicitonary
% Desc: 	creates CMYK color dictionary
%----------------------------------------------------------------------------
/create_cmyk_color
{
  CmykColorSpec 9 dict copy
  begin
    4 array astore /color exch def			% color component values
	/ColorSpace DocCmykSpace def			% document CMYK color space 	
  currentdict end
} bd

%----------------------------------------------------------------------------
% Spot color dictionary definition
%----------------------------------------------------------------------------
/SpotColorSpec
  ColorSpec 9 dict copy
  begin
    /num 1 def											% number of color components/names
		/ColorModel	/Spot def						% color model

		%----------------------------------------------------------------------------
		% Stack: 	--> set_color -->
		% Desc: 	sets color as current
		%----------------------------------------------------------------------------
		/set_color
		{
			ColorSeparationLevel1
			{
				color aload pop get_cmyk_alternative_color /color get aload pop names aload pop findcmykcustomcolor exch setcustomcolor
			}
			{
				ColorSpace safe_setcolorspace
				color aload pop setcolor
			}
			ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			currentdict false					% retvalue - default case, no separation
			SeparationPlateIndex 4 eq			% make sure current plate is spot plate
			{
				names aload pop SeparationPlateName eq
				{
					color aload pop						% get tint on current spot separation plate
					dup 0 gt							% duplicate tint value to be consumed by comparison
					{
						% remove current color and retvalue from stack
						3 1 roll pop pop

						% tint is not zero - we have separation
						SeparateInColor
						{
							% convert color to CMYK to paint separation in color
							pop convert_to_cmyk true
						}
						{
							% separate to gray color
							1 exch sub create_grayscale_color true
						} ifelse
					}
					{
						pop % remove duplicated tint from stack
					} ifelse
				} if
			} if
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			/alternativeSpace ColorSpace 2 get def		% get alternative colorspace
			/tintTransformProc ColorSpace 3 get def		% get tint transformation procedure

			alternativeSpace DocCmykSpace eq
			{
				% alternative space is CMYK, create CMYK color from alternative color values
				color aload pop tintTransformProc create_cmyk_color
			}
			{
				alternativeSpace DocRgbSpace eq
				{
					% alternative space is RGB, create RGB color from alternative color values
					% and convert RGB color to CMYK
					color aload pop tintTransformProc create_rgb_color /convert_to_cmyk dexec
				}
				{
					alternativeSpace DocGrayScaleSpace eq
					{
						% alternative space is grayscale, invert spot tint and use as K component of CMYK color
						0 0 0 color aload pop 1 sub create_cmyk_color
					}
					{
						0 0 0 1 create_cmyk_color
					}ifelse
				} ifelse
			} ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> get_cmyk_alternative_color --> colorspec
		% Desc: 	obtains CMYK representation of this spot color
		%----------------------------------------------------------------------------
		/get_cmyk_alternative_color
		{
			/alternativeSpace ColorSpace 2 get def		% get alternative colorspace

			alternativeSpace DocCmykSpace eq
			{
				% alternative space is CMYK, create CMYK color from alternative color values
				alternativeColor aload pop create_cmyk_color
			}
			{
				alternativeSpace DocRgbSpace eq
				{
					% alternative space is RGB, create RGB color from alternative color values
					% and convert RGB color to CMYK
					alternativeColor  aload pop create_rgb_color /convert_to_cmyk dexec
				}
				{
					alternativeSpace DocGrayScaleSpace eq
					{
						% alternative space is grayscale
						alternativeColor  aload pop create_grayscale_color /convert_to_cmyk dexec
					} 
					{
						0 0 0 1 create_cmyk_color
					}ifelse
				} ifelse
			} ifelse
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_spot_colorspace
% Stack: 	name [alternativeColor] alternativeSpace  --> create_spot_colorspace -- > colorspace
%				name - spot color name
%				alternativeSpace - alternative colorspace (/DocGrayScaleSpace, /DocRgbSpace, /DocCmykSpace )
%				alternativeColor - spot color representation in alternative colorspace
% Desc: 	creates spot ( named ) colorspace
%----------------------------------------------------------------------------
/create_spot_colorspace
{
  load /alternativeSpace xd
  /alternativeColor xd
  /name xd
 
  [ /Separation name alternativeSpace [ alternativeColor alternativeSpace /spot_tint_transform_proc cvx ] cvx ]
} bd

%----------------------------------------------------------------------------
% Proc:		create_spot_color
% Stack:	tint spotSpace --> create_spot_color -- >colorspec or
%         tint name [alternativeColor] alternativeSpace --> create_spot_color -- >colorspec or
%						tint - spot color ink value
%						name - spot color name
%						alternativeColor - spot color representation in alternative colorspace
%						alternativeSpace - alternative colorspace (/DocGrayScaleSpace, /DocRgbSpace, /DocCmykSpace )
% Desc: 	creates spot ( named ) colorspec. Uses spot colorspace on stack or creates
% 				new colorspace from stack parameters
%----------------------------------------------------------------------------
/create_spot_color
{
	SpotColorSpec 9 dict copy
  begin
 		dup type /arraytype ne
    {
			create_spot_colorspace				% create spot colorspace from stack parameters
    } if
		/ColorSpace xd
    /color exch 1 array astore def	% color component values
    ColorSpace 1 get 1 array astore
    /names xd												% spot color name
  currentdict end
} bd

%----------------------------------------------------------------------------
% DeviceN color dictionary definition
% Inherited from SpotColorSpec as there are strong similarities between
% spot and DeviceN colors, spot being 1 ink DeviceN color
%----------------------------------------------------------------------------
/DevicenColorSpec
  SpotColorSpec 9 dict copy
  begin
		/ColorModel	/DeviceN def							% color model

    %----------------------------------------------------------------------------
		% Stack: 	--> set_color -->
		% Desc: 	separates color, if necessary, and sets as current
		%----------------------------------------------------------------------------
		/set_color
		{
			Level3
			{
				% Level 3 support DeviceN colors natively
				ColorSpace safe_setcolorspace
				color aload pop setcolor
			}
			{
				% for Level 2 output color in alternative colorspace
				ColorSpace 2 get setcolorspace
				color aload pop ColorSpace 3 get exec setcolor
			} ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			currentdict false			% default case - no separation

			/PlateIndex -1 def

			0 1 num 1 sub
			{
				dup
				names exch get SeparationPlateName eq
				{
					/PlateIndex xd
					exit
				} if
				pop
			} for

			PlateIndex 0 ge
			{
				color PlateIndex get														% get separation ink tint
				dup 0 gt
				{
					% tint not zero - have separation
					SeparateInColor
					{
						% convert DeviceN plate color to CMYK to paint separation in color

						% leave only separation component in DeviceN
						num 1 sub {0} repeat num PlateIndex roll

						% create temp DeviceN color with single component and convert it to DeviceN
						ColorSpace create_devicen_color /convert_to_cmyk dexec true
					}
					{
						% separate to gray color
						1 exch sub create_grayscale_color true
					} ifelse
					4 2 roll pop pop
				}
				{
					pop
				} ifelse
			} if
		} bd

    %----------------------------------------------------------------------------
		% Stack: 	i --> get_ink_as_spot --> colorspec
		%					i - DeviceN colorant index
		%					colorspec - DeviceN colorant as spot color
		% Desc: 	returns i-th colorant as spot color
		%----------------------------------------------------------------------------
		/get_ink_as_spot
		{
			dup /indexInk xd
			dup color exch get		% get i-th colorant tint
			exch names exch get		% get i-th colorant name
			[											% start array of alternativeColor values
				1.0 num 1 sub {0} repeat num indexInk roll		% set i-th ink to 1.0, the rest to 0.0
				ColorSpace 3 get exec								% execute tint conversion proc to convert i-th ink to alt color space
			]
			ColorSpace 2 get											% get alternative space
			create_spot_color											% create spot color
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_devicen_colorspace
% Stack: 	[names] [ alternativeColor1 ] ... [alternativeColorN ]  alternativeSpace N --> create_devicen_colorspace -- > colorspace
%				N - number of color components in DeviceN color
%				alternativeSpace - alternative color space to define DeviceN in
%				alternativeColori - alternative color values for i-th DeviceN colorant
%				names - colorant names
% Desc: 	creates DeviceN colorspace
%----------------------------------------------------------------------------
/create_devicen_colorspace
{
  /numColorants xd
  load /alternativeSpace xd
  bind /tintTransform exch def
  /names xd

  [ /DeviceN names alternativeSpace /tintTransform load ]
} bd

%----------------------------------------------------------------------------
% Proc:	create_devicen_color
% Stack: 	C1...CN DeviceNColorspace --> create_devicen_color -- >colorspec or
%				C1...CN [names] [ alternativeColor1 ] ... [alternativeColorN ]  alternativeSpace N --> create_devicen_color -- >colorspec
%				C1..CN - DeviceN color components values
%				DeviceNColorspace - DeviceN colorspace array
% Desc: 	creates DeviceN colorspec. Either uses DeviceN colorspace on stack ot creates new colorspace
%				from stack parameters
%----------------------------------------------------------------------------
/create_devicen_color
{
  DevicenColorSpec 9 dict copy
  begin
    dup type /arraytype ne
    {
      create_devicen_colorspace				% create DeviceN colorspace from stack parameters
    } if
    /ColorSpace xd										% CSA or device colorspace array
    /num ColorSpace 1 get length def	% number of color components/names
    /names ColorSpace 1 get def				% color components names
    num array astore /color xd				% color component values
  currentdict end
} bd

%----------------------------------------------------------------------------
% Registratin color dictionary definition
% registration color separates to all plates
%----------------------------------------------------------------------------
/RegistrationColorSpec
  ColorSpec 9 dict copy
  begin
    /num 1 def										% number of color components/names
 		/ColorModel	/Registration def	% color model
    /ColorSpace										% CSA or device colorspace array
    {
      [ /Separation /All DocCmykSpace { dup dup dup } ]
    } def
    /names [/All] def							% color components names

			%----------------------------------------------------------------------------
		% Stack: 	--> set_color -->
		% Desc: 	sets color as current
		%----------------------------------------------------------------------------
		/set_color
		{
			ColorSeparationLevel1
			{
				% paint in gray on all plates
				DocGrayScaleSpace safe_setcolorspace
				color aload pop 1 exch sub setcolor
			}
			{
				ColorSpace safe_setcolorspace
				color aload pop setcolor
			}
			ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			SeparateInColor
			{
				convert_to_cmyk true
			}
			{
				color aload pop 1 exch sub create_grayscale_color true
			} ifelse
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			color aload pop dup dup dup create_cmyk_color
		} bd
	currentdict end
def


%----------------------------------------------------------------------------
% Proc:		create_registration_color
% Stack: 	tint --> create_registration_color -- >colorspec
%					tint - tint of registration colorant
% Desc: 	registration color is a color that will separate to all plates
%					for composite output tint will appear in all channel, including spot and DeviceN
%----------------------------------------------------------------------------
/create_registration_color
{
  RegistrationColorSpec 9 dict copy
  begin
    1 array astore /color xd	% color component values
  currentdict end
} bd

%----------------------------------------------------------------------------
% LAB color dictionary definition
%----------------------------------------------------------------------------
/LabColorSpec
	ColorSpec 9 dict copy
  begin
    /names {/L /a /b} def			% color components names
    /num 3 def						% number of color components/names
	/ColorModel	/Lab def			% color model
    /ColorSpace DocLabSpace def		% LAB CSA

		%----------------------------------------------------------------------------
		% Stack: 	--> separate_color --> colorspec bool
		%					colorspec - separated color
		%					bool - separation result : true - color is separated, false - no separation
		% Desc: 	separates color according to global separation settings and leaves
		%					separated color and separation result on stack
		%----------------------------------------------------------------------------
		/separate_color
		{
			convert_to_cmyk /separate_color dexec
		} bd

		%----------------------------------------------------------------------------
		% Stack: 	--> convert_to_cmyk --> colorspec
		% Desc: 	converts current colorspec to CMYK colorspec
		%----------------------------------------------------------------------------
		/convert_to_cmyk
		{
			0 0 0 0 create_cmyk_color
		} bd
	currentdict end
def

%----------------------------------------------------------------------------
% Proc:	create_lab_color
% Stack: 	L a b --> create_lab_color -- >colorspec
%			L, a, b - L, a, b color components respectively
%			colorspec - colorspec dicitonary
% Desc: 	creates LAB color dictionary
%----------------------------------------------------------------------------
/create_lab_color
{
	LabColorSpec 9 dict copy
	begin
		3 array astore /color exch def		% color component values
		/ColorSpace DocLabSpace def			% LAB color space 	
	currentdict end
} bd

%----------------------------------------------------------------------------
% Proc:		set_solid_fill
% Stack: 	colorspec --> set_solid_fill -->
%					colorspec - color of the fill
% Desc: 	sets fill color and fill type to solid
%----------------------------------------------------------------------------
/set_solid_fill
{
  /FillColor xd
	/$fil 0 def
} bd

%----------------------------------------------------------------------------
% Proc:		set_outline
% Stack: 	colorspec --> set_outline -->
%					colorspec - color of the outline
% Desc: 	sets outline color
%----------------------------------------------------------------------------
/set_outline
{
  /OutlineColor xd
} bd

%----------------------------------------------------------------------------
% Proc:   CheckLevelCompatibility
% Stack:  - CheckLevelCompatibility -
% Desc:   check the PostScript level of the interpeter/device against the
%         the PostScript level of the document we outputed, if not compatable
%         print error message and exit smoothly.
%----------------------------------------------------------------------------
/CheckLevelCompatibility
{
  /DocPsLevel where           	% make sure that Document level is defined
  {
    pop
    DocPsLevel get_ps_level gt  % if document level (LV) is 2 or more and the
    {                         	% device is not 2 or more
      @np                     	% newpath
      /Courier findfont 12    	% set a font
      scalefont setfont
      72 144 m                	% moveto 2 inch off the bottom of the page
      (The PostScript level of Corel document is higher than the PostScript) show
      72 132 m
      (level of this device. Change the PS Level in the Corel application) show
      72 120 m
      (by selecting the PostScript tab in the print dialog, and selecting) show
      72 108 m
      (document level from the Compatibility drop down list.) show
      flush
      spg
      quit
    } if
  } if
} bd

%----------------------------------------------------------------------------
% These two functions serve as a hook for PIPELINE ASSOCIATES INC..
% They have implemented a Corel dictionary in their interpreter. It
% performs mostly exotic fill rendering in .C code (instead of our
% PS code). The key here is to make sure their dictionary is above ours
% on the dictionary stack!!
%
% Notes: The first function should be called at the beginning of the script
%        AFTER our dictionary has been put pushed.
%        The second function should be called at the end of the script
%        BEFORE our dictionary is popped.
%
% Contact: Stephen Kochan (President)  (973)428-1700
%          Tim Demarest (Developer)
%
% New in Draw 8: A similar hook for Lexmark printers. They have also
%                implemented direct support for our fountain fills.
%
%                The key difference between Lexmark and Pipeline's
%                hook is that an integer, 1, is pushed on the stack. This
%                represents a compatibility level for the Exotic Fill routines.
%                When Corel makes a new version of CorelDRAW, this number should
%                be incremented if changes were made to the fountain fill code
%                which would make it ncompatible with existing Lexmark printers.
%
%
%----------------------------------------------------------------------------
/@BeginSysCorelDict
{
 % Pipeline hook...
 systemdict /Corel30Dict known {systemdict /Corel30Dict get exec} if

 % Lexmark hook...
 systemdict /CorelLexDict known {1 systemdict /CorelLexDict get exec} if
} bd

/@EndSysCorelDict
{
 % Pipeline hook...
 systemdict /Corel30Dict known {end} if

 %Lexmark hook...
 /EndCorelLexDict where {pop EndCorelLexDict} if
} bd

%----------------------------------------------------------------------------
% Autoflatness for paths too complex to image.
% The next section is to avoid the limitcheck error of typesetters.
% The painting operators of PostScript are rewritten to increase
% flatness until either the object can be printed, or a flatness
% of 10 more than the initial flatness setting has been reached.
% In this case an error message is displayed and printing continues with
% the next object.
% The auto-flatness will be enabled only if the value of the "AutoFlatness"
% variable is true. The code to set this flag is output by the client app.
%----------------------------------------------------------------------------
/AutoFlatness where
{
 pop

 AutoFlatness
 {
	 %----------------------------------------------------------------------------
	 % @ifl Increase flatness			initial_flatness @ifl initial_flatness
	 %----------------------------------------------------------------------------
	 /@ifl
	 {
		dup currentflat
		exch sub 10 gt             	% Is current flatness increase > 10?
		{
		 ([Error: PathTooComplex; OffendingCommand: AnyPaintingOperator]\n)
		 print flush @np exit
		}
		{
		 currentflat 2 add setflat
		} ifelse
	 } bd

	 %----------------------------------------------------------------------------
	 % --- Then redefine fill, eofill, clip, eoclip, & stroke
	 %----------------------------------------------------------------------------
	 /@fill /fill ld
	 /fill
	 {
		currentflat
		{
		 {@fill} stopped
		 {@ifl}
		 {exit}
		 ifelse
		} bind loop
		setflat
	 } bd

	 /@eofill /eofill ld
	 /eofill
	 {
		currentflat
		{
		 {@eofill} stopped
		 {@ifl}
		 {exit}
		 ifelse
		} bind loop
		setflat
	 } bd

	 /@clip /clip ld
	 /clip
	 {
		currentflat
		{
		 {@clip} stopped
		 {@ifl}
		 {exit}
		 ifelse
		} bind loop
		setflat
	 } bd

	 /@eoclip /eoclip ld
	 /eoclip
	 {
		currentflat
		{
		 {@eoclip} stopped
		 {@ifl}
		 {exit}
		 ifelse
		} bind loop
		setflat
	 } bd

	 /@stroke /stroke ld
	 /stroke
	 {
		currentflat
		{
		 {@stroke} stopped
		 {@ifl}
		 {exit}
		 ifelse
		} bind loop
		setflat
	 } bd
	} if
} if

%----------------------------------------------------------------------------
% Proc:	@ssa
% Stack:	- @ssa -
% Desc:	turn strokeadjust on if we're using level 2
%----------------------------------------------------------------------------
/@ssa
  Level2
  {
    {true setstrokeadjust}
  }
  {
    {}
  } ifelse
bd

%----------------------------------------------------------------------------
/d /setdash ld               	% d  setdash     					array offset d -
/j /setlinejoin ld           	% j  set line join     		join j -
/J /setlinecap ld            	% J  set line cap       	cap J -
/M /setmiterlimit ld         	% M  set miter limit  		value M -
/w /setlinewidth ld          	% w  set line width    		width w -
/O {/FillOverprint xd} bd     % O  set overprint fill   flag O -
/R {/OutlineOverprint xd} bd  % R  set overprint stroke	flag R -
/W /eoclip ld          				% W  clip path          	- W -
/c /curveto ld               	% c  curveto smooth    		x1 y1 x2 y2 x3 y3 c -
/C /c ld                     	% C  curveto corner    		x1 y1 x2 y2 x3 y3 C -
/l /lineto ld                	% l  lineto smooth     		x y l -
/L /l ld                     	% L  lineto corner     		x y L -
/rl /rlineto ld              	% rl rlineto     					x y rl -
/m /moveto ld                	% m  moveto      					x y m -
/n /newpath ld               	% n  newpath     					- n -
/N /newpath ld               	% N  newpath     					- N -
/P {11 rp} bd                	% P  pattern stroke    		(same as p)
/u {} bd                     	% u  begin group        	- u -
/U {} bd                     	% U  end group          	- U -
/A {pop} bd                  	% A  locked object     		flag A -
/q /@gs ld                   	% q  gsave        				- g -
/Q /@gr ld                   	% Q  grestore     				- Q -
/& {}bd                      	% &  pattern marker    		- & -
/@j {@sv @np} bd             	% StartArrowhead
/@J {@rs} bd                 	% EndArrowhead

%----------------------------------------------------------------------------
% Proc: 	g
% Stack:	gray g -
% Desc:		set gray color for solid fill
%----------------------------------------------------------------------------
/g
{
 1 exch sub           				% get black component
 0 0 0 4 roll 3
 create_cmyk_color set_solid_fill
 /$fil 0 def       						% set name (null), fill type
} bd

%----------------------------------------------------------------------------
% Proc:		G
% Stack:	gray G -
% Desc:		set gray outline color
%----------------------------------------------------------------------------
/G
{
 1 sub neg            				% get black component
 0 0 0 4 -1 roll
 create_cmyk_color set_outline
} bd

%----------------------------------------------------------------------------
% Proc: 	i
% Stack: 	flatness i -
% Desc: 	Sets the current flatness
%----------------------------------------------------------------------------
/i
{
 dup 0 ne
 {setflat}
 {pop}
 ifelse
} bd

%----------------------------------------------------------------------------
% Curveto procedures
%----------------------------------------------------------------------------
/v                           	% v		curveto smooth    	x12 y12 x3 y3 v -
{
 4 -2 roll                   	% get x12 y12 on top
 2 copy                      	% duplicate them
 6 -2 roll c                 	% move x3 y3 back to the end
} bd

/V /v ld                     	% V   curveto corner    	x12 y12 x3 y3 V -
/y {2 copy c} bd             	% y   curveto smooth    	x1 y1 x23 y23 y -
/Y /y ld                     	% Y   curveto corner    	x1 y1 x23 y23 Y -

%----------------------------------------------------------------------------
% Proc: 	@w
% Stack: 	[matrix] bscale width height angle @w -
% Desc:		set pen matrix "$ptm" to desired settings
% 				bscale is a flag:
%					0: no scale
%					1: scale with object using matrix supplied on the stack
% 				matrix is passed only if bscale is 1 (object total matrix)
%----------------------------------------------------------------------------
/@w
{
 matrix rotate /$ptm xd      	% define $ptm to be rotation matrix
 matrix scale                	% set pen shape
 $ptm dup concatmatrix
 /$ptm xd
 1 eq                        	% if scale, concat object matrix
 {
  $ptm exch dup concatmatrix
  /$ptm xd
 }if
 
 /patternScallingMatrix where	% apply pattern scaling matrix, if exists, to account for line width scaling in patterns
 {
	pop
	patternScallingMatrix $ptm matrix concatmatrix
	/$ptm xd
 }if
 
 1 w                         	% basic thickness to be transformed by $ptm
} bd

%----------------------------------------------------------------------------
% Proc: 	@g
% Stack: 	freq ang spotproc 1 @g -
%							--or--
%					0 @g - 		(use default)
% Desc:		Set halftone screen for gray filling
% 				spotproc is a spot procedure name (ex: /@dot or /@lin)
%----------------------------------------------------------------------------
/@g
{
 1 eq dup /$sdf xd           	% set global flag
 {                           	% next 3 parameters are set only if parm1 is 1
  /$scp xd                   	% Current spot func for fill
  /$sca xd                   	% Current screen angle for fill
  /$scf xd                   	% Current screen frequency for fill
 } if
} bd

%----------------------------------------------------------------------------
% Proc: 	@G
% Stack: 	freq ang spotproc 1 @G -
%								--or--
%					0 @G - 		(use default)
% Desc:		Set halftone screen for gray stroking
% 				spotproc is a spot procedure name (ex: /@dot or /@lin)
%----------------------------------------------------------------------------
/@G
{
 1 eq dup /$SDF xd           	% set global flag
 {                           	% next 3 parameters are set only if parm1 is 1
  /$SCP xd                   	% Current spot func for stroke
  /$SCA xd                   	% Current screen angle for stroke
  /$SCF xd                   	% Current screen frequency for stroke
 } if
} bd

%----------------------------------------------------------------------------
% Proc: 	@D
% Stack: 	freq ang spotproc @D -
% Desc: 	setscreen for all document
%----------------------------------------------------------------------------
/@D
{
 2 index 0 eq
 {
  $dsf 3 1 roll              	% frequency angle proc deffreq
  4 -1 roll pop
 } if
 3 copy
 exch $Scra add exch load    	%: frequency angle+$Scra {proc}
 SetScr
 /$dsp xd                    	% default spot func name
 /$dsa xd                    	% default screen angle
 /$dsf xd                    	% default screen frequency function
} bd

%----------------------------------------------------------------------------
% Proc: 	$ngx
% Stack:
% Desc: 	set screen function
%----------------------------------------------------------------------------
/$ngx
{
 $SDF
 {
  $SCF
  SeparationMode /Composite eq    % Check if not performing color seps.
  {$SCA}
  {$dsa}
  ifelse
  $SCP
  @ss
 }if      												% alt. screen? (determined by stroke attribs)
} bd

%----------------------------------------------------------------------------
% Proc: 	min
% Stack: 	val1 val2 --> min --> value
% Desc: 	minimum
%----------------------------------------------------------------------------
/min
{
 2 copy le
 {pop}
 {exch pop} ifelse           	% get minimum of both values
} bd

%----------------------------------------------------------------------------
% Proc: 	max
% Stack: 	val1 val2 --> max --> value
% Desc: 	maximum
%----------------------------------------------------------------------------
/max
{
 2 copy ge
 {pop}
 {exch pop}
 ifelse  						         	% get max of both values
} bd

%----------------------------------------------------------------------------
% Proc: 	in_range
% Stack: 	value minimum maximum --> in_range --> newvalue
% Desc: 	forces a value between two limits
%----------------------------------------------------------------------------
/in_range
{
  3 -1 roll                   % get value on top
  min max
} bd

%----------------------------------------------------------------------------
% Proc: 	InRange
% Stack: 	value minimum maximum --> in_range --> newvalue
% Desc: 	The same as in_range, legacy namy for use in PS fills
%----------------------------------------------------------------------------
/InRange /in_range load bd

%----------------------------------------------------------------------------
% Proc:	@sqr
% Stack: 	size @sqr -
% Desc:
%----------------------------------------------------------------------------
/@sqr
{
 dup 0 rl
 dup 0 exch rl
 neg 0 rl
 @cp
} bd

%----------------------------------------------------------------------------
% Proc:		currentscale
% Stack: 	- currentscale sx sy
% Desc:
%----------------------------------------------------------------------------
/currentscale
{
 1 0 dtransform
 matrix defaultmatrix idtransform
 dup mul exch dup mul add sqrt

 0 1 dtransform
 matrix defaultmatrix idtransform
 dup mul exch dup mul add sqrt

} bd

%----------------------------------------------------------------------------
% Proc:		@unscale
% Stack: 	- unscale -
% Desc:
%----------------------------------------------------------------------------
/@unscale
{
 %stub... currentscale 1 exch div exch 1 exch div exch scale
} bd

%----------------------------------------------------------------------------
% Proc: 	wDstChck
% Stack:
% Desc: 	NEEDED by functions in USERPROC.TXT
%----------------------------------------------------------------------------
/wDstChck
{
 2 1 roll dup 3 -1 roll
 eq {1 add} if
} bd

%----------------------------------------------------------------------------
% Proc: 	@dot
% Stack: 	x y @dot num
% Desc:		implementation of a dot spot function for halftoning(see setscreen)
%----------------------------------------------------------------------------
/@dot
{
 dup mul exch dup mul add
 1 exch sub
} bd

%----------------------------------------------------------------------------
% Proc: 	@lin
% Stack: 	x y @lin num
% Desc:		implementation of a line spot function for halftoning(see setscreen)
%----------------------------------------------------------------------------
/@lin
{
 exch pop abs 1 exch sub
} bd

%----------------------------------------------------------------------------
% Proc: 	cmyk2rgb
% Stack: 	c m y k cmyk2rgb r g b
% Desc: 	converts cmyk to rgb using standard algorithm
%----------------------------------------------------------------------------
/cmyk2rgb
{                            	% c m y k
 3
 {
  dup 5 -1 roll             	% m y k k c
  add                       	% m y k k+c
  1 exch sub                	% m y k 1-(k+c)         % r = 1-(k+c)
  dup 0 lt                  	% m y k r r<0
  {
   pop 0                    	% m y k 0               % 0 < r < 1
  } if
  exch                      	% m y r k
 } repeat                   	% r g b k               % for each color
 pop                        	% r g b
} bd

%----------------------------------------------------------------------------
% Proc: 	rgb2cmyk
% Stack: 	r g b rgb2cmyk c m y k
% Desc: 	converts rgb to cmyk using standard algorithm
%----------------------------------------------------------------------------
/rgb2cmyk
{                            	% r g b
 3
 {                           	% r g b
  1 exch sub                 	% r g 1-b       				% y = 1 - b
  3 1 roll                   	% y r g
 } repeat                    	% c m y
 3 copy                      	% c m y c m y
 min min                     	% c m y min(c,m,y)     	% K=min(c,m,y)
 3
 {                           	% c m y K
  dup 5 -1 roll              	% m y K K c
  sub neg                    	% m y K c-K     				% C = c - K
  exch                       	% m y C K
 } repeat                    	% C M Y K
} bd

%----------------------------------------------------------------------------
% Proc: 	rgb2g
% Stack:
% Desc: 	converts rgb to gray using standard algorithm
%----------------------------------------------------------------------------
/rgb2g
{
 2 index .299 mul            	% r g b .299r
 2 index .587 mul add        	% r g b .299r+.587g
 1 index .114 mul add        	% r g b .299r+.587g+.144b
 4 1 roll                    	% gray r g b
 pop pop pop                 	% gray
} bd

%----------------------------------------------------------------------------
% WaldoColor might already be defined if this is an EPS file
%----------------------------------------------------------------------------
/WaldoColor_5 where
{
 pop
}
{
  %----------------------------------------------------------------------------
  % store pointers to actual color operators
  %----------------------------------------------------------------------------
  /CorelImage systemdict /image get def
  /CorelSetGray systemdict /setgray get def
  /CorelGetGray systemdict /currentgray get def
  /CorelSetTransfer systemdict /settransfer get def
  /CorelGetTransfer systemdict /currenttransfer get def

  /SetRgb /setrgbcolor ld
  /GetRgb /currentrgbcolor ld
  /SetGry /setgray ld
  /GetGry /currentgray ld
  /SetRgb2 systemdict /setrgbcolor get def
  /GetRgb2 systemdict /currentrgbcolor get def
  /SetHsb systemdict /sethsbcolor get def
  /GetHsb systemdict /currenthsbcolor get def

  %----------------------------------------------------------------------------
  % Proc: 	rgb2hsb
  % Stack:
  % Desc: 	converts rgb to hsb
  %----------------------------------------------------------------------------
  /rgb2hsb
  {
   SetRgb2
   GetHsb
  } bd

  %----------------------------------------------------------------------------
  % Proc: 	hsb2rgb
  % Stack:
  % Desc: 	converts hsb to rgb
  %----------------------------------------------------------------------------
  /hsb2rgb
  {                            	% h s b
   3 -1 roll                   	% s b h
   dup floor sub               	% s b H         			% ensure 0 < H < 1
   3 1 roll                    	% H s b
   SetHsb
   GetRgb2
  } bd

  %----------------------------------------------------------------------------
  % define the setcmykcolor operator if not already defined
  % if it is already defined, we want to store it away so that when we later
  % superclass this operator to our own in order to separate eps files, we can
  % access the existing call.  If it does not exist, it will be emulated with
  % the corresponding rgb calls.
  %----------------------------------------------------------------------------
  /setcmykcolor where
  {
    pop
    /LumSepsDict where              % check if Luminus TrapWise Separation dictionary is defined
    {
      pop
      /SetCmyk_5
      {
        LumSepsDict                 % get setcmykcolor from their dict and run it
        /setcmykcolor get exec
      } def
    }
    {
      /AldusSepsDict where
      {
        pop
        /SetCmyk_5
        {
          AldusSepsDict             % get setcmykcolor from their dict and run it
          /setcmykcolor get exec
        } def
      }
      {
        /SetCmyk_5 /setcmykcolor ld
      } ifelse
    } ifelse
  }
  {
	%----------------------------------------------------------------------------
	/setcmykcolor
	{
	create_cmyk_color /separate_set_color dexec
	/$ffpnt xd		% painting flag
	} bd

    /SetCmyk_5                      % cyan magenta yellow black setcmykcolor -
    {
      cmyk2rgb
      SetRgb
    } bd
  } ifelse

  %----------------------------------------------------------------------------
  /currentcmykcolor where
  {
   pop
   /GetCmyk
   /currentcmykcolor ld
  }
  {
   /GetCmyk
   {
    GetRgb
    rgb2cmyk
   } bd
  } ifelse

  %----------------------------------------------------------------------------
  % define the setoverprint operator if not already defined
  % NOTE: We do not want to redefine this operator if it is defined so that
  %       other apps can separate our EPS files.
  %----------------------------------------------------------------------------
  /setoverprint where
  {pop}
  {
   /setoverprint               	% boolean setoverprint
   {
    /CurrentOverprint xd
   } bd
  } ifelse

  %----------------------------------------------------------------------------
  % define the currentoverprint operator if not already defined
  % NOTE: We do not want to redefine this operator if it is defined so that
  %       other apps can separate our EPS files.
  %----------------------------------------------------------------------------
  /currentoverprint where
  {pop}
  {
   /currentoverprint           	% currentoverprint boolean
   {
		CurrentOverprint
   } bd
  } ifelse

  %----------------------------------------------------------------------------
  % proc : ColorImage
  %
  % Stack: width height #bits matrix dataaq1 ... dataaqN multi
  %        #colors ColorImage -
  %        where:
  %          dataaqI: Data aquisition function I ( we can have 1, 3 or 4 of them)
  %          multi  : Boolean, true means multi-stram image, false means single stram image
  %
  % Desc : Defines the ColorImage operator
  %				 if colorimage is define it uses the definition for our ColorImage,
  %        if not we will define our own.
  %
  %----------------------------------------------------------------------------
  /colorimage where
  {
   pop
   /ColorImage {colorimage} def	      % 8Dec94: rwm: this used to be /colorimage load def
                                      % it was changed to support colorimage separation
  }
  {
   /ColorImage
   {
     /ncolors xd			                % # of colors
     /$multi xd                       % multi-stream colorimage
     $multi true eq
     {                                % multi-stream colorimage, pop all the image data
       ncolors 3 eq
       {                              % RGB image
         /daqB xd
         /daqG xd
         /daqR xd
         pop pop exch pop abs         % pop the stack leave the # of lines
         {
           daqR pop                   % pop the Red line
           daqG pop                   % pop the Green line
           daqB pop                   % pop the Blue line
         } repeat
       }
       {                              % CMYK image
         /daqK xd
         /daqY xd
         /daqM xd
         /daqC xd
         pop pop exch pop abs         % pop the stack leave the # of lines
         {
           daqC pop                   % pop the Cyan line
           daqM pop                   % pop the Magenta line
           daqY pop                   % pop the Yellow line
           daqK pop                   % pop the Black line
         } repeat
       } ifelse
     }
     {                                % single-stream colroimage
       /dataaq xd
       {
         dataaq
         ncolors dup 3 eq
         {
           /$dat xd
           0 1 $dat length
           3 div 1 sub
           {
             dup 3 mul
             $dat 1 index get
             255 div
             $dat 2 index 1 add get
             255 div
             $dat 3 index 2 add get
             255 div
             rgb2g 255 mul
             cvi exch pop
             $dat 3 1 roll put
           } for
           $dat 0 $dat length 3
           idiv getinterval pop
         }
         {
           4 eq
           {
             /$dat xd
             0 1 $dat length
             4 div 1 sub
             {
               dup 4 mul
               $dat 1 index get
               255 div
               $dat 2 index 1 add get
               255 div
               $dat 3 index 2 add get
               255 div
               $dat 4 index 3 add get
               255 div
               cmyk2rgb rgb2g 255 mul
               cvi exch pop
               $dat 3 1 roll put
             } for
             $dat 0 $dat length
             ncolors idiv
             getinterval
           } if
         } ifelse
       }
       image
     } ifelse
   } bd
  } ifelse

  %----------------------------------------------------------------------------
  /currentcmykcolor
  {
    GetCmyk
  } bd

  %----------------------------------------------------------------------------
  /sethsbcolor
  {
   hsb2rgb
   setrgbcolor
  } bd

  %----------------------------------------------------------------------------
  /currenthsbcolor
  {
   currentrgbcolor
   rgb2hsb
  } bd

  %----------------------------------------------------------------------------
  /setgray
  {
   dup dup
   setrgbcolor
  } bd

  %----------------------------------------------------------------------------
  /currentgray
  {
   currentrgbcolor             	% r g b
   rgb2g
  } bd

  %----------------------------------------------------------------------------
  % Proc:   InsideDCS
  % Desc:   defines the flag InsideDCS file to false, will be set just prior to
  %         outputing a DCS file and reset after that.
  %----------------------------------------------------------------------------
  /InsideDCS false def

  %----------------------------------------------------------------------------
  % Proc: 	IMAGE
  % Stack: 	- IMAGE -
  % Desc: 	load the defined image operater and redefine it into IMAGE
  %----------------------------------------------------------------------------
  /IMAGE /image ld

  %----------------------------------------------------------------------------
  % Proc:   image
  % Stack:  width height bits matrix datasrc image -
  %         dict image -
  % Desc: 	this proc redefine the systemdic image proc. It will either call
  %         the IMAGE if we do not need to do anything to the image, or it
  %         pop all the image data if the image need not to print.
  %----------------------------------------------------------------------------
  /image                            % Redefine image proc
  {
    InsideDCS                       % check if the image is inside a DCS file
    {
      IMAGE                         % play the image
    }
    {
    /EPSDict where                  % check if an EPS dictionary on the stack
    {                               % Inside EPS file
      pop                           % pop dictinary

      SeparationMode /Composite eq
      {                             % composite
        IMAGE                       % use the systemdict image call
      }
      {                             % separation
        dup type /dicttype eq       % check if there is a dictionary on the stack
        {                           % There is a dict, this must ba a LEVEL 2 or 3 IMAGE call,
          dup /ImageType get 1 ne
          {                         % level 3 image dictionary
            IMAGE                   % use the systemdict image call
          }
          {                         % Level 2 image dictionary
            dup dup
            /BitsPerComponent
            get 8 eq exch
            /BitsPerComponent
            get 1 eq or
            currentcolorspace 0 get
            DocGrayScaleSpace eq
            and
            {                       % It is a GrayScale or a Mono image
              SeparationPlateName
              (Black) eq
              {                     % Black plate
                IMAGE               % play the image, use the systemdict image call
              }
              {                     % Not a black plate
                dup /DataSource get
                /TCC xd             % get datasource proc from dictionary and save it
                /Height get abs     % get number of lines
                { TCC pop } repeat  % pop all the image lines
              } ifelse
            }
            {                       % It is not a gray scale image
              IMAGE                 % output the image
            } ifelse
          } ifelse
        }
        {                           % this is a LEVEL 1 IMAGE call
          2 index 1 ne              % get number of bits/sample
          {                         % 8 bits, gray image
            SeparationPlateName
            (Black) eq
            {                       % Black plate
              IMAGE                 % use the systemdict image call
            }
            {                       % Not a black plate
              /TCC xd               % save the datasource proc
              pop pop exch pop abs  % pop image parameters, leaving the number of lines only
              { TCC pop } repeat    % pop all the image lines
            } ifelse
          }
          {                         % 1 bit
            IMAGE                   % use the systemdict image call
          } ifelse
        } ifelse
      } ifelse
    }
    {                               % not in an EPS file
      IMAGE                         % use the systemdict image call
    } ifelse                        %
    } ifelse                        % InsideDCS
  } bd
} ifelse

%----------------------------------------------------------------------------
% Desc: 	sets the fill mode to EVEN_ODD mode.
%----------------------------------------------------------------------------
/$fm 0 def

%----------------------------------------------------------------------------
% Proc: 	wfill
% Stack: 	wfill
% Desc: 	sets the type of fill to use (fill or eofill)
%         depending on the fill mode (winding or even-odd).
%----------------------------------------------------------------------------
/wfill
{
 1 $fm eq					           	% fillmode
 {
  fill												% normal non-zero winding number rule
 }
 {
  eofill											% even-odd rule
 } ifelse
} bd

%----------------------------------------------------------------------------
% Proc: 	@Pf
% Stack: 	- @Pf -
% Desc: 	Postscript Fill
% 				Call user-defined Postscript fill with current parameters
% 				20dec90:MB: Print PS fill only in composite
%           or in black plane of color seps.
% NOTE: All PS fills expect the current UNIT to be MIL (1/1000 inch)
% and Bburx, .. need to be specified in that unit as well.
%----------------------------------------------------------------------------
/@Pf
{
 @sv
 SeparationMode /Composite eq	% Composite or...
 {
  true
 }
 {
  $Psc 0 ne or	 								% Color PS fill or..
  $ink_5 3 eq or
 }ifelse
 								% Black separation
 {                           	% PS fills can be printed
  0 J 0 j [] 0 d             	% reset stroke attributes (all PS fills set line width)
  FillOverprint safe_setoverprint
  FillColor /separate_set_color dexec pop
  $ctm setmatrix             	% reset matrix for PS-filling
  72 1000 div dup
  matrix scale               	% scaling matrix
  dup concat                 	% change current ctm
  dup Bburx exch Bbury exch
  itransform
  ceiling cvi /Bbury xd
  ceiling cvi /Bburx xd      	% change unit of BBox
  Bbllx exch Bblly exch
  itransform
  floor cvi /Bblly xd
  floor cvi /Bbllx xd
  $Prm aload pop             	% Bring the parameters on stack
  $Psn load exec             	% execute the ps fill as desired
 }
 {                           	% Not proper color plane, fill in white instead.
  1 SetGry wfill
 } ifelse
 @rs                         	% restore original state
 @np                         	% and clear the path
} bd

%----------------------------------------------------------------------------
% Proc: 	F
% Stack: 	- F -
% Desc: 	fill path
%----------------------------------------------------------------------------
/F
{
	matrix currentmatrix        					% save current transfo matrix on stack
	$sdf
	{
	$scf $sca $scp @ss
	} if                        					% alternate halftone screen?

	FillOverprint safe_setoverprint

	$fil 1 eq

	{CorelPtrnDoFill}            					% pattern fill
	{
		$fil 2 eq                  					% fountain fill?
		{gradient_fill}                      					% fountain fill path
		{
			$fil 3 eq                 				% Postscript fill?
			{@Pf}                     				% PS fill
			{
				get_simulate_devicen FillColor /ColorModel get /DeviceN eq and
				{
					% simulate DeviceN color on Level 2
					% oveprint N objects with individual DeviceN inks
        	0 1 FillColor /num get 1 sub		% iterate through all DeviceN plates
        	{
          		dup 0 gt											% if not the first plate, overprint it
          		{
            			true safe_setoverprint
          		}if

          		FillColor /get_ink_as_spot dexec	% get DeviceN i-th ink as spot color

          		/set_color	dexec									%	set DeviceN i-th ink as current color

          		@gs
          		wfill															% paint the fill
          		@gr

        	} for
      	}
      	{
        	FillColor /separate_set_color dexec
        	{wfill}
        	{@np} ifelse
      	} ifelse
   } ifelse
  } ifelse
 } ifelse
 $sdf
 {
  $dsf $dsa $dsp @ss
 } if                        				% reset default halftone screen
 setmatrix                   				% reset original transfo matrix on stack
} bd

%----------------------------------------------------------------------------
% Proc: 	f
% Stack: 	- f -
% Desc: 	closepath fill
%----------------------------------------------------------------------------
/f
{
 @cp F
} bd


%----------------------------------------------------------------------------
% Proc: 	S
% Stack: 	- S -
% Desc: 	stroke
%----------------------------------------------------------------------------
/S
{
  matrix currentmatrix        	% save current transfo matrix on stack
  $ctm setmatrix              	% reset normal ctm
  $SDF {$SCF $SCA $SCP @ss}if 	% alternate halftone screen?

  OutlineOverprint safe_setoverprint

  get_simulate_devicen OutlineColor /ColorModel get /DeviceN eq and
	{
		% simulate DeviceN color on Level 2
		% oveprint N objects with individual DeviceN inks

    0 1 OutlineColor /num get 1 sub		% iterate through all DeviceN plates
    {
      dup 0 gt												% if not the first plate, overprint it
      {
        true safe_setoverprint
      }if

      OutlineColor /get_ink_as_spot dexec	% get DeviceN i-th ink as spot color

      /set_color	dexec										%	set DeviceN i-th ink as current color

			matrix currentmatrix
			$ptm concat													% set the pen matrix
			@gs
			stroke
			@gr
			setmatrix														% reset the original matrix(from stack)

    } for
  }
  {
    OutlineColor /separate_set_color dexec
    {
      matrix currentmatrix
      $ptm concat              	% set the pen matrix
      stroke
      setmatrix                	% reset the original matrix(from stack)
    }
    {@np}ifelse
  } ifelse

 $SDF {$dsf $dsa $dsp @ss}if		% reset default halftone screen
 setmatrix                   		% reset original matrix set on stack
} bd

%----------------------------------------------------------------------------
% Proc: 	s
% Stack: 	- s -
% Desc: 	closepath stroke
%----------------------------------------------------------------------------
/s
{
 @cp
 S
} bd

%----------------------------------------------------------------------------
% Proc: 	B
% Stack: 	- B -
% Desc: 	fill, then stroke
%----------------------------------------------------------------------------
/B
{
 @gs F @gr                   	% fill, then
 S                           	% stroke
} bd

%----------------------------------------------------------------------------
% Proc: 	b
% Stack: 	- b -
% Desc: 	closepath, fill, stroke
%----------------------------------------------------------------------------
/b
{
 @cp B
} bd

%----------------------------------------------------------------------------
% Proc: 	E
% Stack: 	name llx lly urx ury description E -
% Desc:		define pattern
% 				a pattern will be defined as an array of 5 entries:
% 				(0)llx (1)lly (2)urx (3)ury (4)descrition
% 				the description is also an array of executable strings
%----------------------------------------------------------------------------
/_E
{
 5 array astore    						% parms are in an array
 exch cvlit xd			      		% defined with key equal to the name(string)
} bd

%----------------------------------------------------------------------------
% Proc: 	@cc
% Stack: 	- @cc string
% Desc: 	collect bitmap data from currentfile (input)
%----------------------------------------------------------------------------
/@cc
{
 currentfile $dat readhexstring pop
} bd

%----------------------------------------------------------------------------
% Proc: 	@sm
% Stack: 	- @sm -
% Desc: 	save current transfo matrix into global $ctm
%----------------------------------------------------------------------------
/@sm
{
 /$ctm $ctm currentmatrix def
} bd

%----------------------------------------------------------------------------
% Proc: 	@E
% Stack: 	bbllx bblly bburx bbury matrix @E -
% Desc: 	Define Object's bbox
% 				Must be called before painting if PATTERNS, PSFILLS, or
% 				FOUNTAINS are used
%----------------------------------------------------------------------------
/@E
{
  /Bbury xd /Bburx xd      		% upper rt. of object's bbox in absolute space
 /Bblly xd /Bbllx xd      		% lower lt. of object's bbox in absolute space
} bd

%----------------------------------------------------------------------------
% Proc: 	@c
% Stack:
% Desc: 	Close sub Path
%					Must be called during the path description
%----------------------------------------------------------------------------
/@c
{
 @cp
} bd

%----------------------------------------------------------------------------
% Proc: 	@P
% Stack: 	parm1 .. parmn n nColor fillname @P -
% Desc: 	PostScript fill
%----------------------------------------------------------------------------
/@P
{       											% COREL Postscript fill # of parms can vary
 /$fil 3 def        					% set global for filling
 /$Psn xd     								% PS-fill name
 /$Psc xd											% 0 - black only, 1 - color
 array astore      						% build array for PS-fill parms
 /$Prm xd     								% parms in Prm
} bd

%----------------------------------------------------------------------------
% Proc: 	tcc
% Stack: 	- tcc -
% Desc:
%----------------------------------------------------------------------------
/tcc {@cc} def 								% no bind def because @cc redefn'

%----------------------------------------------------------------------------
% Proc:		@B
% Stack: 	- @B
% Desc: 	stroke, then fill
%----------------------------------------------------------------------------
/@B
{
 @gs S   @gr         					% stroke
 F              							% fill
} bd

%----------------------------------------------------------------------------
% Proc:		@b
% Stack: 	- @b -
% Desc: 	closepath, stroke & fill path
%----------------------------------------------------------------------------
/@b
{
 @cp @B
} bd

%----------------------------------------------------------------------------
% Proc:		init_separation
% Stack: 	--> init_separation -->
% Desc: 	initialize global color separation parameters
%
%       	SeparationMode defines the current mode for color separation :
%						/Composite - no color separation
%           /OnHost - colors are separated in the application ( on host )
%           /InRip - colors are separated in the RIP
%
%       	SeparationPlateName - string defining the current color plane being
%  					printed.  The possible values are (case sensitive, not to be
%						translated); /Cyan, /Magenta, /Yellow, /Black or any spot color
%						defined in the document; e.g. (Pantone 345)
%
%					SeparationPlateIndex - index of separation plate, -1 - not defined,
%					0 - Cyan,	1 - Magenta, 2 - Yellow, 3 - Black, 4 - any spot
%
%----------------------------------------------------------------------------
/init_separation
{
	% inherit separation parameters from parent document if embedded as EPS
	/SeparationMode where
	{
		pop
	}
	{
		/SeparationMode /Composite def
	} ifelse


	/SeparationPlateName where
	{
		pop
	}
	{
		/SeparationPlateName null def
	} ifelse

	/SeparateInColor where
	{
		pop
	}
	{
		/SeparateInColor false def
	} ifelse

	SeparationMode /Composite eq
	{
		/SeparationPlateIndex -1 def
	}
	{
		/SeparationPlateIndex 4 def
	} ifelse

	/CmykPlates [ /Cyan /Magenta /Yellow /Black ] def

	0 1 3
	{
		dup
		CmykPlates exch get SeparationPlateName eq
		{
			/SeparationPlateIndex xd
			exit
		} if
		pop
	} for

	% init legacy separation parameters used for separation of pre-X5
	% generated embedded EPS documents

	/CurrentInkName_5 SeparationPlateName def

	/$ink_5 SeparationPlateIndex def

	SeparationMode /OnHost eq
	{
		/SepMode_5 2 def
	}
	{
		/SepMode_5 0 def
	} ifelse

	/SepsColor SeparateInColor def	
} bd

%----------------------------------------------------------------------------
% Proc:		init_separation_from_legacy
% Stack: 	- init_separation_from_legacy -
% Desc: 	inits separation from legacy pre-X5 separation parameters
%----------------------------------------------------------------------------
/init_separation_from_legacy
{
	EpsFile
	{
		/SepMode_5 where
		{
			pop
			SepMode_5 2 eq
			{
				/SeparationMode /OnHost def
			}
			{

				/SeparationMode /Composite def
			}
			ifelse
		} if
		
		/CurrentInkName_5 where
		{
			pop
			/SeparationPlateName CurrentInkName_5 def
		} if
		
		/$ink_5 where
		{	pop
			/SeparationPlateIndex $ink_5 def
		} if
		
		/SepsColor where
		{
			pop
			/SeparateInColor SepsColor def
		} if
	} if
} bd

init_separation_from_legacy

%----------------------------------------------------------------------------
% Proc:		@whi
% Stack: 	- @whi -
% Desc: 	Fill Page white
%----------------------------------------------------------------------------
/@whi
{
 @gs
 -72000 dup m
 -72000 72000 l
 72000 dup l
 72000 -72000 l
 @cp 1 SetGry fill
 @gr
} bd

%----------------------------------------------------------------------------
% Proc:		@neg
% Stack: 	- @neg -
% Desc: 	MAKE ALL COLORS NEGATIVE
% 				Only set the GRAY scale transfer function since WALDO only
% 				uses negative for color separations.
%----------------------------------------------------------------------------
/@neg
{  [{1 exch sub} /exec cvx currenttransfer /exec cvx] cvx settransfer
 @whi          								% fill page in white (Will be turned into white)
} bd

%----------------------------------------------------------------------------
% ------------------------- AX system --------------------------------------
%----------------------------------------------------------------------------
/deflevel 0 def								% global

%----------------------------------------------------------------------------
% Proc:		@sax
% Stack: 	- @sax -
% Desc: 	start an excution array
% NOTE:		an array should be started IMMEDITAELY AFTER @sax
%         each @sax requires a following @eax
%----------------------------------------------------------------------------
/@sax
{
  /deflevel deflevel 1 add def
} bd

%----------------------------------------------------------------------------
% Proc:		@eax
% Stack: 	[ex array] @eax -
%         or
%         [ ... [ex array] @eax [ ... [ex array] {ex array code}
% Desc: 	end and possibly execute an execution array
%         This will either load array execution code or execute the
%         array depending on the level (as set by @sax).
%         EACH @eax needs a preceding @sax
%----------------------------------------------------------------------------
/@eax
{
 % decrement deflevel but NEVER below 0.
 /deflevel deflevel dup 0 gt {1 sub} if def
 deflevel 0 gt
 {
  /eax load       						% push eax code onto stack for later execution
 }
 {
  eax       									% execute the array on the stack NOW
 }
 ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		eax
% Stack: 	[ex array] eax -
% Desc: 	execute an execution array
% NOTE:		This should only be called by @eax. DO NOT DIRECTLY
%         CALL THIS ROUTINE!
%----------------------------------------------------------------------------
/eax
{
 {exec} forall
} bd

%----------------------------------------------------------------------------
% Proc:		@rax
% Stack:
% Desc:
%----------------------------------------------------------------------------
/@rax
{
 deflevel 0 eq
 {
  @rs @sv
 }
 if
} bd

%----------------------------------------------------------------------------
% Proc:		pdfmark
% Stack: 	[ .... pdfmark
% Desc:
%----------------------------------------------------------------------------
systemdict /pdfmark known not
{
 /pdfmark /cleartomark ld
} if

%----------------------------------------------------------------------------
% Proc: 	wclip
% Stack: 	- wclip -
% Desc: 	sets the type of clipping to use (clip or eoclip)
%         depending on the clipping mode (winding or even-odd).
%----------------------------------------------------------------------------
/wclip
{
 1 $fm eq						% fillmode
 {
  clip							% normal non-zero winding number rule
 }
 {
  eoclip						% even-odd rule
 } ifelse
} bd
%----------------------------------------------------------------------------
% Raster images support
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
% Proc: 	set_image_clipping
% Stack: 	cropllx croplly cropurx cropury matrix --> set_image_clipping -->
% Desc: 	set clipping path for image
%----------------------------------------------------------------------------
/set_image_clipping
{
 concat      									% integrate transfo right away
 3 index 3 index m        		% set clipping path(cropping rect)
 3 index 1 index l
 2 copy l
 1 index 3 index l
 3 index 3 index l
 clip         								% this is the clipping path
 pop pop pop pop							% pop cropping rect
} bd

%----------------------------------------------------------------------------
% Proc: 	set_image_parameters
% Stack: 	pxlwid pxlhei bits llx lly urx ury background foreground
%         		 ---> set_image_parameters -->
% Desc: 	sets image parameters from stack
%----------------------------------------------------------------------------
/set_image_parameters
{
	/$frg xd /$bkg xd						% foreground/background flags
	/$ury xd /$urx xd
	/$lly xd /$llx xd          	% bitmap rectangle
	/$ncl xd           					% # of color components
	/$bts xd           					% # of bits per color component
	/$hei xd /$wid xd           % pixel size
} bd

%----------------------------------------------------------------------------
% Proc:		output_image
%
% Stack: 	pxlwid pxlhei bits bitplanes
%         		llx lly urx ury backgroundflag foregroundflag
%         		cropllx croplly cropurx cropury matrix
%        		dataproc --> output_image -->
%
% Desc: 	output bitmap image
%
% Parms:  pxlwid pxlhei 	size of bitmap in pixels
%         bits 				# of bits per sample
%         bitplanes  		# of color planes
%         llx lly urx ury 	total size of bitmap(before transfos)
%         backgroundflag
%						1: fill background with current fill,
%           0: transparent background (only for monochrome/grayscale bitmaps)
%         foregroundflag :
%						1: mask background with current stroke,
%           0: transparent background (only for monochrome/grayscale bitmaps)
%         cropllx croplly cropurx cropury: cropping rect (before transfos)
%         matrix 			 additional transfo matrix for stretching/rotating, etc..
%         dataproc :		data acquisition procedure
%
%       	Note:  pxlhei < 0 prints bitmap UPSIDE down
%
%----------------------------------------------------------------------------
/output_image
{
 /@cc xd											% store data aquisition procedure

	@sm @gs     								% save current ctm and graphics state
	set_image_clipping          % set CTM and clipping

	set_image_parameters				% store image parameters from stack

	SeparationMode /OnHost eq EpsFile and
	{
		separate_output_image
	}
	{
		output_composite_image
	} ifelse

	@gr $ctm setmatrix          % Restore graphics state & org matrix
} bd

%----------------------------------------------------------------------------
% Proc:		output_composite_image
% Stack: 	--> output_composite_image -->
% Desc: 		output bitmap image in composite mode
%----------------------------------------------------------------------------
/output_composite_image
{
	DocPsLevel 3 eq							% Using Level 3
	MaskedImage true eq	and
	{
		output_masked_image   		% call level 3 masked images code
	}
	{
	 $bts 1 gt              		% grayscale or color?
	 DocPsLevel 2 eq						% and using level 2 or 3?
	 DocPsLevel 3 eq or
	 and
	 {
		DevicenImage							% check if DeviceN image
		{
			output_devicen_image   	% output DeviceN image to Level2 and 3
		}
		{
			output_color_image			% call level 2 color bitmap code
		}ifelse
	 }
	 {													% level 1 or monochrome?
		$bts 1 eq    							% check for 1 bitplane (monochrome)
		{
		 output_monochrome_image
		}
		{
		 output_color_image_level1	% call level 1 bitmap code
		} ifelse
	 } ifelse
  } ifelse
} bd

%----------------------------------------------------------------------------
% Proc:		separate_output_image
% Stack: 	--> separate_output_image -->
% Desc: 		separates image according to global separation parameters then outputs it
%----------------------------------------------------------------------------
/separate_output_image
{
	@gs
	$bts 1 gt
	{
		separate_output_color_image
	}
	{
		separate_output_monochrome_image
	} ifelse
	@gr

	not	% if not separated to current plate, check if we need to knock image out
	{
		currentoverprint not
		{
			% knock out image by painting white rectangle
			1.0 SetGry
			wfill
		} if
	} if

	@np
} bd

%----------------------------------------------------------------------------
% Stack: 	file --> set_decode_filter --> file
% Params:	file - current file object with installed filter chain on top
% Desc: 	installs image data decode filter on top of filter chain
%----------------------------------------------------------------------------
/set_decode_filter
{
	ImageCompression /JPEG eq				% JPEG compression
	{
		/DCTDecode filter
	}
	{
		ImageCompression /RLE eq			% RunLengthDecode filter
		{
			/RunLengthDecode filter
		}
		{
			ImageCompression /LZW eq		% LZWDecode filter
			{
				/LZWDecode filter
			}if
		} ifelse
	} ifelse
} bd

%----------------------------------------------------------------------------
% Proc: 	create_datasource
% Stack: 	--> create_datasource --> file
%	Params:	file - current file object with installed filter chain on top
% Desc: 	creates image datasource as current file with edecoding filters chain
%----------------------------------------------------------------------------
/create_datasource
{
	currentfile
	
	DevicenImage not get_ps_level 2 gt or
	{	/ASCII85Decode filter
	}if

	set_decode_filter
} bd

%----------------------------------------------------------------------------
% Proc: 		set_image_strip_parameters
% Stack: 	numPlanes stripRows --> set_image_strip_parameters  -->
% Params:	numPlanes - number of planes to output image strip to
%				stripRows - number of image rows in single strip
% Desc: 		sets parameters for outputing image strip
%----------------------------------------------------------------------------
/set_image_strip_parameters
{
	/stripRows xd
	/numPlanes xd

	/stripBuffer										% buffer for strip data
		$wid $bts
		mul $ncl mul
		stripRows mul
		8 div
		ceiling cvi
		dup 65535 gt
		{
			pop $ncl $bts mul 
		}if
		string

	def

	DevicenImage
	{
		/readstrip
		{
			DataSource stripBuffer readhexstring pop
		} bd
	}
	{
		/readstrip
		{
			DataSource stripBuffer readstring pop
		} bd
	}ifelse

	/stripHeight																% height of image strip
		$lly $ury sub stripRows mul $hei div
	def

	/stripOutBuffer															% buffer for strip data converted for output
		$wid stripRows mul numPlanes mul 65535 min string
	def

	/strip_img_dict 8 dict def
	strip_img_dict begin
		/ImageType 1 def													% image type - there's only 1
		/Width $wid def														% source width
 		/Height stripRows def         						% source height
		/BitsPerComponent $bts def 								% bits per sample
 		/Decode
			[numPlanes {0 1} repeat] def						% decode output strip data
		/ImageMatrix 															% map unit square to source
			[ $wid 0 0 stripRows neg 0
				$hei 0 gt	{stripRows}{0}	ifelse			% matrix( upside down if $hei is negative )
			]
		def
 		/DataSource stripOutBuffer def						%	data source decode the entire bitmap
	end
} bd

%----------------------------------------------------------------------------
% Proc:		separate_output_color_image
% Stack: 	--> separate_output_color_image --> separated
%				separated - true if image has been separated to current plate
% Desc: 		separates color or grayscale image according to global
%				separation parameters and then outputs it
%----------------------------------------------------------------------------
/separate_output_color_image
{
	/plateContent false def
	$ncl 1 eq
	{
		% grayscale image, separate to Black plate
		SeparationPlateName /Black eq
		{
			% output monochrome image to Black plate
			output_color_image
			/plateContent true def
		} if
	}
	{
		% separate DeviceN, CMYK or RGB image
		@np          									% no path but clipping

		/DataSource create_datasource def

		SeparateInColor
		{
			DocCmykSpace setcolorspace 			% CMYK colorspace for painting separation plates in color
			/numPlanes 4 def
		}
		{
			DocGrayScaleSpace setcolorspace % grayscale for default painting separation plates in black
			/numPlanes 1 def
		} ifelse

		% claculate strip size  ( in image rows )  to fit PostScript string length limit of 65535
		/stripRows 65535 $wid $bts mul $ncl numPlanes max mul 8 div div floor cvi 1 max def

		numPlanes stripRows set_image_strip_parameters

		/maxStripIndex $hei stripRows div ceiling cvi 1 sub def

		0 1 maxStripIndex 					% iterate through strips
		{
			/stripIndex exch def			% save buffer index

			/$t_ury										% calculate rectangle for strip image
				$ury stripHeight stripIndex mul add ceiling cvi
			def

			/$t_lly											% calculate rectangle for strip image
				$t_ury stripHeight add ceiling cvi
			def

			stripIndex maxStripIndex eq % last strip, adjust strip size to fit all data that remains
			{
				numPlanes $hei maxStripIndex stripRows mul sub set_image_strip_parameters

				/$t_lly										% adjust strip image rectangle
					$t_ury stripHeight add ceiling cvi
				def
			} if

			readstrip pop								% read image data from the file

			@gs

			% separate color for each image pixel
			0 1 $wid stripRows mul 1 sub
			{
				/pixelIndex xd

				stripBuffer pixelIndex $ncl mul $ncl getinterval			% get color values array for single pixel from image strip

				{ 255 div } forall																		% image colors are 0..255 encoded, convert to 0.0..1.0

				% convert pixel color
				DevicenImage
				{
						ImageDevicenSpace create_devicen_color
				}
				{
					$ncl 3 eq
					{
						create_rgb_color
					}
					{
						create_cmyk_color
					} ifelse
				} ifelse

				/separate_color dexec

				{	% check if color has been separated to the current plate
					/plateContent true def
					% extract color values from colorspec
					begin
						color aload pop
					end
				}
				{
					pop numPlanes [ numPlanes 1 eq {1}{0}ifelse ] cvx repeat
				} ifelse


				numPlanes array astore																% pack alt colors value into array

				/pixelSepIndex pixelIndex numPlanes mul def

				/posColorant 0 def
				{
				 stripOutBuffer pixelSepIndex posColorant add 3 -1 roll 255 mul cvi put
				 /posColorant posColorant 1 add def										% put alt color values into separated strip buffer
				} forall
			} for

			$llx $t_lly Tl								% translate gstate origin
			$urx $llx sub
			$t_ury $t_lly sub scale				% set current scale for bitmap size

			strip_img_dict								% scanline image dictionary
			image													% draw image

			@gr
		}for

	  $SDF {$dsf $dsa $dsp @ss}if  		% reset default halftone screen
	} ifelse

	plateContent											% leave separation flag on stack
} bd

%----------------------------------------------------------------------------
% Proc:		separate_output_monochrome_image
% Stack: 	--> separate_output_monochrome_image --> separated
%				separated - true if image has been separated to current plate
% Desc: 		separates monochrome image according to global
%				separation parameters and then outputs it
%----------------------------------------------------------------------------
/separate_output_monochrome_image
{
	SeparationPlateName /Black eq
	{
		% output monochrome image to Black plate
		output_monochrome_image true
	}
	{
		false
	} ifelse
} bd

%----------------------------------------------------------------------------
% Proc: 	output_monochrome_image
% Stack:  --> output_monochrome_image -->
% Desc: 	Outputs Grayscale/Mono bitmap
%----------------------------------------------------------------------------
/output_monochrome_image
{
	$frg 1 eq                 			% Check if foreground flag is set.
	{
		OutlineOverprint safe_setoverprint
		ImageForegroundColor /separate_set_color dexec		% Set foreground color
		{1}{0}ifelse
		/$frg xd
	}
	{
		/$frg false def
	} ifelse

	$bkg 1 eq                 % Check if background flag is set.
	{                      		% Not set for bitmap fill.
	 @gs $ctm setmatrix
	 F
	 @gr
	} if

	@np          								% no path but clipping

	/$dat $wid $bts mul 8 div ceiling cvi 65535 min string def    % string for data entry (each scan line)

	$bkg $frg add 1 ge
	{
		$SDF {$SCF $SCA $SCP @ss}if % alternate halftone screen? (determined by stroke attribs)
																% set params for the imagemask/image operator
		$llx $lly Tl
		$urx $llx sub $ury $lly sub scale

		% For monochrome bitmaps, the foreground colour is currently set.
		$bkg 1 eq
		{
		 FillColor /separate_set_color dexec pop
		} if

		$wid $hei abs          			% if height is negative, print it upside down
		$bts 1 eq
		{$bkg 1 ge }
		{$bts 1 ge }
		ifelse 											% either false or #bits/sample
		[ $wid 0 0
			$hei neg 0
			$hei 0 gt{$hei}{0}ifelse] % matrix(upside down if $hei is negative)
		/tcc load             			% @cc can be redefined
		$bts 1 eq
		{imagemask}
		{image}
		ifelse

		$SDF {$dsf $dsa $dsp @ss}if % reset default halftone screen
	}
	{
		$hei abs {tcc pop} repeat   % skip all lines
	} ifelse
} bd

%----------------------------------------------------------------------------
% Proc: 		output_color_image_level1
% Stack: 	--> output_color_image_level1 -->
% Desc: 		Outputs color bitmap on level 1 device
%----------------------------------------------------------------------------
/output_color_image_level1
{
	@np          								     % no path but clipping
	$ngx    											   % set screening function

	$llx $lly Tl
	$urx $llx sub
	$ury $lly sub scale              % set current scale for bitmap size
																	 % set parameters on stack for colorimage call:
	$wid $hei abs $bts        		   % width height #bits matrix
	[ $wid 0 0
	 $hei neg 0
	 $hei 0 gt{$hei}{0}ifelse        % matrix(upside down if $hei is negative)
	]

	/$dat $wid $bts mul $ncl mul
	8 div ceiling cvi 65535 min string def     % string for data entry (each scan line)

	$msimage false eq
	$ncl 1 eq or
	{                                % single-stream colorimage or grayscale
	 /@cc load
	 false $ncl
	 ColorImage              			   % colorimage redefined.
	}
	{                                % set parameters for multi-stream colorimage
	 $wid $bts mul 8 div ceiling cvi % calculate length of string
	 $ncl 3 eq
	 {                               % RGB colorimage
		 dup dup
		 /$dat1 exch string def        % string for data entry, Red component.
		 /$dat2 exch string def        % string for data entry, Green component.
		 /$dat3 exch string def        % string for data entry, Blue component.
		 /@cc1 load
		 /@cc2 load
		 /@cc3 load
	 }
	 {                               % CMYK colorimage
		 dup dup dup
		 /$dat1 exch string def        % string for data entry, Cyan component.
		 /$dat2 exch string def        % string for data entry, Magenta component.
		 /$dat3 exch string def        % string for data entry, Yellow component.
		 /$dat4 exch string def        % string for data entry, Black component.
		 /@cc1 load
		 /@cc2 load
		 /@cc3 load
		 /@cc4 load
	 } ifelse
	 true $ncl ColorImage
	} ifelse

	$SDF {$dsf $dsa $dsp @ss} if      % reset default halftone screen
} bd

%----------------------------------------------------------------------------
% Proc: 	@cc1
% Stack: 	- @cc1 string
% Desc: 	collect bitmap data from currentfile (input)
%----------------------------------------------------------------------------
/@cc1
{
 currentfile $dat1 readhexstring pop
} bd

%----------------------------------------------------------------------------
% Proc: 	@cc2
% Stack: 	- @cc2 string
% Desc: 	collect bitmap data from currentfile (input)
%----------------------------------------------------------------------------
/@cc2
{
 currentfile $dat2 readhexstring pop
} bd

%----------------------------------------------------------------------------
% Proc: 	@cc3
% Stack: 	- @cc3 string
% Desc: 	collect bitmap data from currentfile (input)
%----------------------------------------------------------------------------
/@cc3
{
 currentfile $dat3 readhexstring pop
} bd

%----------------------------------------------------------------------------
% Proc: 	@cc4
% Stack: 	- @cc4 string
% Desc: 	collect bitmap data from currentfile (input)
%----------------------------------------------------------------------------
/@cc4
{
 currentfile $dat4 readhexstring pop
} bd

%----------------------------------------------------------------------------
% Multi-Stream Image ($msimage)
% sets the default value for the $msimage operator.
%
% false : the image contains one data stream
% true  : the image data is specified in multi-stream input
%----------------------------------------------------------------------------
/$msimage false def

%----------------------------------------------------------------------------
% sets the default value for the compression method, by default
% we do NOT use any filters,
%
% 0 : no compression is set
% 1 : indicates a JPEG compression filter
% 2 : a Run Length Encoding filter
% 3 : LZW compression filter
%----------------------------------------------------------------------------
/ImageCompression /None def
/MaskedImage false def

/DevicenImage false def

%----------------------------------------------------------------------------
% Proc: 		output_color_image
% Stack: 	--> output_color_image -->
% Desc: 		Output color bitmap using Level 2 image dictionary
%----------------------------------------------------------------------------
/output_color_image
{
	@np          									% no path but clipping

	$ncl 1 eq											% set device color space
	{DocGrayScaleSpace}						%	use document's grayscale colorspace
	{
		$ncl 3 eq
		{DocRgbSpace}								%	use document's RGB colorspace
		{DocCmykSpace}							%	use document's CMYK colorspace
		ifelse
	} ifelse
	setcolorspace

	/$dat $wid $bts mul $ncl mul
	8 div ceiling cvi 65535 min string def 	% string for data entry (each scan line)

	$ngx    											% set screening function

	$llx $lly Tl									% translate gstate origin
	$urx $llx sub $ury $lly sub scale  % set current scale for bitmap size

	8 dict begin                 	% start a Level 2 image dictionary
		/ImageType 1 def            % required: image type - there's only 1
		/Width $wid def							%	required: source width
		/Height $hei abs def        % required: source height
		/BitsPerComponent $bts def 	%	required: bits per sample
		/Decode                     % required: decode array (to follow)
			[ $ncl { 0 1 } repeat ]		% create decode array for DeviceN image
		def
		/ImageMatrix 								% required: map unit square to source
			[ $wid 0 0 $hei neg 0
				$hei 0 gt	{$hei}{0}	ifelse
			]
		def                      		% matrix(upside down if $hei is negative)
		/DataSource create_datasource def
	currentdict end              	% end image dictionary
	image			              			% call the image operator
	$SDF {$dsf $dsa $dsp @ss}if  	% reset default halftone screen
} bd

%----------------------------------------------------------------------------
% Proc: 		simulate_devicen_image
% Stack: 	--> simulate_devicen_image -->
% Desc: 		simulating DeviceN image on Level 2 device by overprinting n  single-channel images
% Notes:		as there is not enough memory to hold whole image we output image strip by strips
%----------------------------------------------------------------------------
/simulate_devicen_image
{
	@np          										% no path but clipping
	$ngx    												% set screening function

	/colorantNames	ImageDevicenSpace 1 get def		% get DeviceN colorants name
	/altColorSpace ImageDevicenSpace 2 get	def		% get DeviceN alternative colorspace
	/tintProc ImageDevicenSpace 3 get def					% get tint procedure to convert from DeviceN to alt colorspace

	/DataSource create_datasource def

	% claculate strip size  ( in image rows )  to fit PostScript string length limit of 65535
	/stripRows 65535 $wid $bts mul $ncl mul 8 div div floor cvi 1 max def

	1 stripRows set_image_strip_parameters

	/maxStripIndex $hei stripRows div ceiling cvi 1 sub def

	0 1 maxStripIndex						% iterate through strips
	{
		/stripIndex exch def			% save buffer index

		/$t_ury										% calculate rectangle for strip image
			$ury stripHeight stripIndex mul add ceiling cvi
		def

		/$t_lly										% calculate rectangle for strip image
			$t_ury stripHeight add ceiling cvi
		def

		stripIndex maxStripIndex eq % last strip, adjust strip size to fit all data that remains
		{
			1 $hei maxStripIndex stripRows mul sub set_image_strip_parameters

			/$t_lly										% adjust strip image rectangle
				$t_ury stripHeight add ceiling cvi
			def
		} if

		readstrip pop							% read image data from the file

		% simulate DeviceN output by overprinting n single channel images
		@gs

		$llx $t_lly Tl					% translate gstate origin
		$urx $llx sub
		$t_ury $t_lly sub
		scale										% set current scale for bitmap size

		0 1 $ncl 1 sub						% iterate through DeviceN plates
		{
			@gs
			/inkIndex exch def			% save current DeviceN plate index

			0 1 stripOutBuffer length 1 sub
			{
				dup
				$ncl mul inkIndex add stripBuffer exch get
				stripOutBuffer 3 1 roll put
			}for

			[ /Separation colorantNames inkIndex  get altColorSpace
				{																					% construct one channel tint transform function
					$ncl 1 sub {0} repeat										% convert single colorant color into n-channel DeviceN color
					$ncl inkIndex roll
					tintProc																% convert DeviceN color into alternative colorspace
				}
			] setcolorspace

			inkIndex 0 gt
			{
				true setoverprint
			} if

			strip_img_dict image		% draw single scanline image

			@gr			              	% restore graphics state
		}for
		@gr
	}for

  $SDF {$dsf $dsa $dsp @ss}if  				% reset default halftone screen
} bd

%----------------------------------------------------------------------------
% Proc: 		output_devicen_image_alt
% Stack: 	--> output_devicen_image_alt -->
% Desc: 		outputing DeviceN image to Level 2 device in alternative colorspace
%----------------------------------------------------------------------------
/output_devicen_image_alt
{
	@np          										% no path but clipping
	$ngx    												% set screening function

	/colorantNames	ImageDevicenSpace 1 get def		% get DeviceN colorants name
	/altColorSpace ImageDevicenSpace 2 get	def		% get DeviceN alternative colorspace
	/tintProc ImageDevicenSpace 3 get def					% get tint procedure to convert from DeviceN to alt colorspace

	% determine how many colorants are in alternative colorspace
	altColorSpace DocCmykSpace eq
	{
		/numAltChannels 4 def
	}
	{
		altColorSpace DocRgbSpace eq
		{
			/numAltChannels 3 def
		}
		{
			/numAltChannels 1 def
		} ifelse
	}ifelse

	/DataSource create_datasource def
	
	altColorSpace setcolorspace			% use alternative colorspace

	% claculate strip size  ( in image rows )  to fit PostScript string length limit of 65535
	/stripRows 65535 $wid $bts mul $ncl numAltChannels max mul 8 div div floor cvi 1 max def

	numAltChannels stripRows set_image_strip_parameters

	/maxStripIndex $hei stripRows div ceiling cvi 1 sub def

	0 1 maxStripIndex 							% iterate through strips
	{
		/stripIndex exch def			% save buffer index

		/$t_ury										% calculate rectangle for strip image
			$ury stripHeight stripIndex mul add ceiling cvi
		def

		/$t_lly										% calculate rectangle for strip image
			$t_ury stripHeight add ceiling cvi
		def

		stripIndex maxStripIndex eq % last strip, adjust strip size to fit all data that remains
		{
			numAltChannels $hei maxStripIndex stripRows mul sub set_image_strip_parameters

			/$t_lly										% adjust strip image rectangle
				$t_ury stripHeight add ceiling cvi
			def
		} if

		readstrip pop							% read image data from the file

		@gs

		% output DeviceN image in alternative colorspace
		0 1 stripBuffer length $ncl div cvi 1 sub
		{
			/pixelIndex xd

			stripBuffer pixelIndex $ncl mul $ncl getinterval			% get DeviceN color values array for single pixel from image scanline

			{ 255 div } forall																		% image colors are 0..255 encoded, convert to 0.0..1.0

			tintProc exec																					% convert DeviceN 0.0..1.0 encoded color values to alt colorspace

			numAltChannels array astore														% pack alt colors value into array

			/pixelAltIndex pixelIndex numAltChannels mul def

			/posColorant 0 def
			{
			 stripOutBuffer pixelAltIndex posColorant add 3 -1 roll 255 mul cvi put
			 /posColorant posColorant 1 add def										% put alt color values into alt colorspace scanline
			} forall
		} for

		$llx $t_lly Tl								% translate gstate origin
		$urx $llx sub
		$t_ury $t_lly sub scale				% set current scale for bitmap size

		strip_img_dict								% scanline image dictionary
		image													% draw image

		@gr
	}for

  $SDF {$dsf $dsa $dsp @ss}if  				% reset default halftone screen
} bd

%----------------------------------------------------------------------------
% Proc: 		output_devicen_image_native
% Stack: 	--> output_devicen_image_native -->
% Desc: 		Output DeviceN image natively in Level3
%----------------------------------------------------------------------------
/output_devicen_image_native
{
	@np          											% no path but clipping
	$ngx    													% set screening function

	ImageDevicenSpace setcolorspace		% set DeviceN colorspace

	/scanline
		$wid $bts
		mul $ncl mul
		8 div
		ceiling cvi 65535 min string
	def 															% string for scanline data

	/readscanline
	{
		currentfile	scanline readhexstring pop
	} bind def

	$llx $lly Tl											% translate gstate origin
	$urx $llx sub $ury $lly sub scale % set current scale for bitmap size

	8 dict begin                 			% start a Level 2 image dictionary
		/ImageType 1 def             		% image type - there's only 1
		/Width $wid def									%	source width
		/Height $hei abs def         		% source height
		/BitsPerComponent $bts def 			%	bits per sample
		/Decode                     		% decode array (to follow)
			[ $ncl { 0 1 } repeat ]				% create decode array for DeviceN image
		def
		/ImageMatrix 										% required: map unit square to source
		[ $wid 0 0 $hei neg 0
				$hei 0 gt	{$hei}{0}	ifelse
		]	def                      			% matrix(upside down if $hei is negative)
		/DataSource											%	required: data source decode the entire bitmap
		{
			readscanline
		} def
	currentdict end              			% end image dictionary

	image			              					% call the image operator

  $SDF {$dsf $dsa $dsp @ss}if  			% reset default halftone screen
} bd


%----------------------------------------------------------------------------
% Proc: 	output_devicen_image
%
% Stack: 	pxlwid pxlhei bits ncolors llx lly urx ury cropllx croplly
%					cropurx cropury	matrix --> output_devicen_image -->
%
% Desc: 	Output DeviceN image
%
% Parms: 	colorspace				DeviceN image colorspace
%					pxlwid pxlhei 		size of bitmap in pixels
%         bits 							bits per component
%         ncolors 					color components (RGB=3, CMYK=4)
%         llx lly urx ury 	size of bitmap (before transfos)
%         cropllx croplly cropurx cropury: cropping rectangle (before transfos)
%         matrix: 					transfo matrix for stretching/rotating, etc..
%					Note :	Level 3 device - image will be output in native DeviceN colorspace
%									Level 2 Distiller or in-RIP separation - image will be output as
%									series of N overprinted bitmaps ( scanline by scanline )
%									Level 2 composite - image will be output in alternative colorspace
%
%----------------------------------------------------------------------------
/output_devicen_image
{
	Level3
	{
		output_devicen_image_native
	}
	{
		get_simulate_devicen
		{
			simulate_devicen_image
		}
		{
			output_devicen_image_alt
		} ifelse
	} ifelse
} bd

%----------------------------------------------------------------------------
% Proc: 	output_masked_image
%
% Stack: 	pxlwid pxlhei bits ncolors llx lly urx ury cropllx croplly
%					cropurx cropury	matrix output_masked_image -
%
% Desc: 	Output level 3 color bitmap with mask
%
% Parms: 	pxlwid 	:
%					pxlhei	: size of bitmap in pixels
%         bits		: bits per component
%         ncolors	: color components (RGB=3, CMYK=4)
%         llx lly urx ury: 	size of bitmap (before transfos)
%         cropllx croplly cropurx cropury: cropping rectangle (before transfos)
%         matrix	: transfo matrix for stretching/rotating, etc.
%
%----------------------------------------------------------------------------
/output_masked_image
{
	/$dat $wid $bts mul $ncl mul
	8 div ceiling cvi 65535 min string def 	% string for data entry (each scan line)
	$ngx    											% set screening function

	DevicenImage									% DeviceN image
	{
		ImageDevicenSpace
	}
	{
		$ncl 1 eq										% set device color space
		{DocGrayScaleSpace}         %	use document's grayscale colorspace
		{
			$ncl 3 eq
			{DocRgbSpace}             %	use document's RGB colorspace
			{DocCmykSpace}            %	use document's CMYK colorspace
			ifelse
		} ifelse
	} ifelse
	setcolorspace

	$llx $lly Tl									% translate gstate origin
	$urx $llx sub
	$ury $lly sub scale						% set current scale for bitmap size

	/ImageDataDict 8 dict def			% start image data dictionary
	ImageDataDict begin
		/ImageType	1 def           % modified type 1 image dictionary
		/Width			$wid def				%	required: source width
		/Height			$hei abs def    % required: source height
		/BitsPerComponent $bts def 	%	required: bits per sample
		/Decode											% required: decode array (to follow)
		[ $ncl { 0 1 } repeat ]
		def

		/ImageMatrix [ 							%	required: image matrix
			$wid 0 0 $hei neg 0
			$hei 0 gt{$hei}{0} ifelse %	matrix(upside down if $hei is negative)
 		] def

		/DataSource create_datasource def
	end                           % end image data dictionary

	/MaskedImageDict 7 dict def   % start masked image dictionary
	MaskedImageDict begin
		/ImageType 3 def            % masked image
		/InterleaveType 3 def       % mask and data appear in separate streams
		/MaskDict ImageMaskDict def % dictionary to define mask
		/DataDict ImageDataDict def % dictionary to define data
	end

  MaskedImageDict image					% do the image

	$SDF {$dsf $dsa $dsp @ss}if  	% reset default halftone screen
} bd

%----------------------------------------------------------------------------
% Proc: 	set_image_mask
% Stack: 	pxlwid pxlhei bits set_image_mask -
%
% Desc: 	Level 3 set mask for masked images
%
% Parms: 	pxlwid 	:	Width of mask in pixels
%					pxlhei	: Height of mask in pixels
%         bits		: bits per mask component, must be 1 for InterleaveType 3
%----------------------------------------------------------------------------
/set_image_mask
{
	/$mbts xd           					% store # of bits for mask
	/$mhei xd 										%	height of mask
	/$mwid xd            					% width of mask

	/ImageMaskDict 8 dict def
	ImageMaskDict begin
		/ImageType 1 def            % modified type 1 image dictionary
		/Width		 $mwid def				%	required: source width
		/Height		 $mhei abs def		% required: source height
		/BitsPerComponent $mbts def %	required: bits per sample, must be 1 for InterleaveType 3

		/DataSource maskstream def	%	required for InterleaveType 3: data source of the mask

		/ImageMatrix [ 							%	required: image matrix
			$mwid 0 0 $mhei neg 0
			$mhei 0 gt
			{$mhei}{0} ifelse					%	matrix(upside down if $hei is negative)
 		] def

		/Decode [ 1 0 ] def         % required: mask 0 values.
	end                           % end image mask dictionary
} bd

%----------------------------------------------------------------------------
% Proc:		@daq
% Stack: 	one or more <arrays of data strings | data strings> daq -
% Desc: 	standard bitmap data acquistion routine
% NOTE:		This assumes ONLY arrays of data strings or data
%         strings are on the stack and that there are ENOUGH data
%         strings (total) for the specified bitmap.
%----------------------------------------------------------------------------
/@daq
{
 dup type /arraytype eq   		% is this an array
 {
  aload pop          					% dump strings in array onto stack
 }
 if            								% otherwise, should be a string, so leave it
} bd

%----------------------------------------------------------------------------
% Proc:		skip_image_body
%
% Stack: 	pxlwid pxlhei bits bitplanes
%         llx lly urx ury backgroundflag foregroundflag
%         cropllx croplly cropurx cropury matrix
%         dataproc --> skip_image_body -->
%
% Desc: 	skip over image binary body leaving stack clean

% NOTE:		This call should be followed by enable_raster_output call to restore
%					output_image function
%----------------------------------------------------------------------------
/skip_image_body
{
	8 rp  					% get rid of parameters on stack we do not need
	/$ury xd /$urx xd       % store the image rectangle
	/$lly xd /$llx xd       % still storing the image rectangle
	/$ncl xd           		% store # of color components
	/$bts xd           		% store # of bits per color component
	/$hei xd /$wid xd       % store pixel size

	DevicenImage not
	ImageCompression /JPEG eq or
	ImageCompression /RLE eq or
	ImageCompression /LZW eq or
	{
		create_datasource flushfile
	}
	{
		/scanline			% define string to keep single string of image data
			$wid $bts
			mul $ncl mul
			8 div
			ceiling cvi
			dup 65535 gt
			{
				pop $bts $ncl mul
			}if
			string
		def

		/upperBound $wid $hei mul $bts mul $ncl mul scanline length div cvi 1 sub def 
		0 1 upperBound			% iterate through image using scanline buffer
		{
			pop
			currentfile scanline readhexstring
			pop pop				% discard whatever we read
		}for
	}ifelse
}bd

%----------------------------------------------------------------------------
% Proc:		disable_raster_output
%
% Stack: 	--> disable_raster_output -->
%
% Desc: 	overload output_image procedure by skip_image_body procedure
%					which skips image data
%
% NOTE:		This call should be followed by enable_raster_output call to restore
%					output_image function
%----------------------------------------------------------------------------
/disable_raster_output
{
	deflevel 0 eq { @rs	} if
		
	/output_image load					% load current output_image function
	/output_image_original exch	% and save it
	def													% bind it there

	/output_image /skip_image_body load def	% overload function
	
	globaldict begin /bSkipDeviceNImage true def end
	
	deflevel 0 eq { @sv	} if
}def

%----------------------------------------------------------------------------
% Proc:		enable_raster_output
% Stack: 	--> enable_raster_output -->
% Desc: 	Function restores overloaded output_image function
% NOTE:		This call should go after disable_raster_output call
%----------------------------------------------------------------------------
/enable_raster_output
{
	deflevel 0 eq { @rs	} if
	
	/bSkipDeviceNImage where		% check whether output_image has been overloaded
	{
		/bSkipDeviceNImage undef
		
		/output_image /output_image_original load def		% load original raster function and assign it to output_image
	}if
	
	deflevel 0 eq { @sv	} if
}def


end
%%EndResource
%%EndProlog
%%BeginSetup
wCorel21Dict begin
@BeginSysCorelDict
/$dcm matrix currentmatrix def
@ssa
1.00 setflat
/$fst 128 def
%%EndSetup

%%Page: 1 1
%%ViewingOrientation: 1 0 0 1
%%BoundingBox: 0 0 595 841
%LogicalPage: 1
%%BeginPageSetup
@sv
@sm
@sv
%%EndPageSetup
@rax %Note: Object
115.71449 655.14671 144.41244 775.22202 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
130.06346 655.14671 m
137.98743 655.14671 144.41244 661.80898 144.41244 670.02803 C
144.41244 771.68154 L
144.41244 773.63660 142.88372 775.22202 140.99868 775.22202 C
119.12825 775.22202 L
117.24321 775.22202 115.71449 773.63660 115.71449 771.68154 C
115.71449 670.02803 L
115.71449 661.80898 122.13950 655.14671 130.06346 655.14671 C
@c
S

@rax %Note: Object
123.35357 661.40787 136.77364 674.82794 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
130.06346 661.40787 m
126.35745 661.40787 123.35357 664.41175 123.35357 668.11776 C
123.35357 671.82378 126.35745 674.82794 130.06346 674.82794 C
133.76948 674.82794 136.77364 671.82378 136.77364 668.11776 C
136.77364 664.41175 133.76948 661.40787 130.06346 661.40787 C
@c
S

@rax %Note: Object
123.35357 690.83093 136.77364 704.25099 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
130.06346 690.83093 m
126.35745 690.83093 123.35357 693.83480 123.35357 697.54082 C
123.35357 701.24683 126.35745 704.25099 130.06346 704.25099 C
133.76948 704.25099 136.77364 701.24683 136.77364 697.54082 C
136.77364 693.83480 133.76948 690.83093 130.06346 690.83093 C
@c
S

@rax %Note: Object
121.62359 709.96535 138.50249 719.33641 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
133.81852 709.96535 m
126.30841 709.96535 L
123.72066 709.96535 121.62359 712.06328 121.62359 714.65131 C
121.62359 717.23849 123.72066 719.33641 126.30841 719.33641 C
133.81852 719.33641 L
136.40542 719.33641 138.50249 717.23849 138.50249 714.65131 C
138.50249 712.06328 136.40542 709.96535 133.81852 709.96535 C
@c
S

@rax %Note: Object
125.24343 746.24627 134.88265 769.52835 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
125.24343 767.48740 m
125.24343 768.61446 126.15761 769.52835 127.28466 769.52835 C
132.84255 769.52835 L
133.96961 769.52835 134.88265 768.61446 134.88265 767.48740 C
134.88265 748.28636 L
134.88265 747.15931 133.96961 746.24627 132.84255 746.24627 C
127.28466 746.24627 L
126.15761 746.24627 125.24343 747.15931 125.24343 748.28636 C
125.24343 767.48740 L
@c
S

@rax %Note: Object
120.64252 720.99241 139.48441 739.83430 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
130.06346 739.83430 m
135.26646 739.83430 139.48441 735.61635 139.48441 730.41335 C
139.48441 725.21036 135.26646 720.99241 130.06346 720.99241 C
124.86047 720.99241 120.64252 725.21036 120.64252 730.41335 C
120.64252 735.61635 124.86047 739.83430 130.06346 739.83430 C
@c
S

@rax %Note: Object
67.96857 324.23669 300.81118 805.44217 @E
/$fm 0 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000 1.0000  create_cmyk_color set_outline
0 1.00006 1.00006 0.00000 @w
282.01606 800.33754 m
285.84255 782.82539 L
286.59657 778.62643 286.90668 774.34894 286.76835 770.08507 C
286.67622 767.25326 L
285.42416 769.79480 L
283.31943 774.06746 279.92041 777.61928 275.48135 779.46066 C
272.01288 780.89924 266.96891 781.30772 263.27877 781.26633 C
262.56217 781.25839 L
262.56217 802.08652 L
155.48967 802.08737 L
155.48967 781.26746 L
154.01395 781.26746 L
151.73320 781.26746 150.59650 779.37024 150.59650 777.27600 C
150.59650 669.96709 L
150.59650 659.26035 141.36661 648.95329 130.43310 648.95329 C
119.57301 648.95329 109.70419 659.18381 109.70419 669.96709 C
109.70419 777.21307 L
109.70419 779.43713 108.13748 781.27880 105.83915 781.20369 C
103.41865 781.12460 101.01685 780.94828 98.61789 780.61011 C
89.05805 779.26337 82.68463 772.43216 81.28290 763.01972 C
81.18170 762.34025 L
79.81739 762.50013 L
80.01978 764.87046 L
80.67657 772.55972 81.99865 780.17556 83.41455 787.76646 C
86.93348 805.18309 L
77.65455 805.44217 L
67.96857 805.17827 L
67.96857 691.77657 L
72.21657 691.77657 l
73.93153 691.77657 75.33468 690.37342 75.33468 688.65846 c
75.33468 629.76104 l
75.33468 628.04608 73.93153 626.64293 72.21657 626.64293 c
67.96857 626.64293 L
67.96857 607.47080 L
72.21657 607.47080 l
73.93153 607.47080 75.33468 606.06765 75.33468 604.35269 c
75.33468 578.71389 l
75.33468 576.99893 73.93153 575.59578 72.21657 575.59578 c
67.96857 575.59578 L
67.96857 326.07269 L
77.12589 325.80907 L
87.14863 326.06957 L
85.40872 332.97477 L
83.56847 340.27795 81.40961 347.40283 80.49146 354.90926 C
79.99228 358.99115 L
79.90923 359.67061 79.92198 360.53717 79.89619 361.23250 C
79.87096 361.91792 79.87408 362.68271 79.80973 363.35962 C
79.72866 364.04617 L
81.10346 364.23780 L
81.21345 363.55266 L
82.74926 354.00104 88.92624 347.00060 98.61789 345.63600 C
100.77250 345.33241 102.95830 345.18217 105.13162 345.09430 C
105.81165 345.06680 L
105.81562 324.23669 L
263.78220 324.23669 L
263.78135 345.08381 L
264.45430 345.11783 L
266.35890 345.21420 268.26293 345.36983 270.15194 345.63600 C
279.83764 347.00031 286.25046 353.98630 287.54986 363.53565 C
287.64085 364.20406 L
288.98476 364.08841 L
288.81553 359.45206 L
288.81383 359.43279 L
287.92602 349.71647 285.20022 340.33663 282.93676 330.87487 C
282.02485 327.27969 L
290.05427 326.42079 L
291.12831 326.30570 292.20945 326.25468 293.28945 326.28557 C
300.79644 326.50072 L
300.80466 597.72047 L
295.42677 597.72047 l
293.86772 597.72047 292.59213 598.99606 292.59213 600.55512 c
292.59213 625.44869 l
292.59213 627.00775 293.86772 628.28334 295.42677 628.28334 c
300.80580 628.28334 L
300.80750 685.09559 L
294.57638 685.09559 l
292.23780 685.09559 290.32441 687.00898 290.32441 689.34756 c
290.32441 736.09824 l
290.32441 738.43682 292.23780 740.35020 294.57638 740.35020 c
300.80920 740.35020 L
300.81118 800.33754 L
282.01606 800.33754 L
@c
S

@rax %Note: Object
111.43304 330.76403 116.00702 335.33603 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
113.72088 330.76403 m
112.45805 330.76403 111.43304 331.78706 111.43304 333.05017 C
111.43304 334.31216 112.45805 335.33603 113.72088 335.33603 C
114.98287 335.33603 116.00702 334.31216 116.00702 333.05017 C
116.00702 331.78706 114.98287 330.76403 113.72088 330.76403 C
@c
S

@rax %Note: Object
118.89496 330.76403 123.46894 335.33603 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
121.18309 330.76403 m
119.91997 330.76403 118.89496 331.78706 118.89496 333.05017 C
118.89496 334.31216 119.91997 335.33603 121.18309 335.33603 C
122.44507 335.33603 123.46894 334.31216 123.46894 333.05017 C
123.46894 331.78706 122.44507 330.76403 121.18309 330.76403 C
@c
S

@rax %Note: Object
126.38098 330.76403 130.95298 335.33603 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
128.66683 330.76403 m
127.40400 330.76403 126.38098 331.78706 126.38098 333.05017 C
126.38098 334.31216 127.40400 335.33603 128.66683 335.33603 C
129.92995 335.33603 130.95298 334.31216 130.95298 333.05017 C
130.95298 331.78706 129.92995 330.76403 128.66683 330.76403 C
@c
S

@rax %Note: Object
133.68302 330.76403 138.25587 335.33603 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
135.97002 330.76403 m
134.70690 330.76403 133.68302 331.78706 133.68302 333.05017 C
133.68302 334.31216 134.70690 335.33603 135.97002 335.33603 C
137.23200 335.33603 138.25587 334.31216 138.25587 333.05017 C
138.25587 331.78706 137.23200 330.76403 135.97002 330.76403 C
@c
S

@rax %Note: Object
141.01483 330.76403 145.58683 335.33603 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
143.30098 330.76403 m
142.03701 330.76403 141.01483 331.78706 141.01483 333.05017 C
141.01483 334.31216 142.03701 335.33603 143.30098 335.33603 C
144.56296 335.33603 145.58683 334.31216 145.58683 333.05017 C
145.58683 331.78706 144.56296 330.76403 143.30098 330.76403 C
@c
S

@rax %Note: Object
255.21109 789.77310 260.06400 794.62715 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
257.63783 794.62715 m
258.97805 794.62715 260.06400 793.54006 260.06400 792.20013 C
260.06400 790.86019 258.97805 789.77310 257.63783 789.77310 C
256.29789 789.77310 255.21109 790.86019 255.21109 792.20013 C
255.21109 793.54006 256.29789 794.62715 257.63783 794.62715 C
@c
S

@rax %Note: Object
233.03310 786.37011 245.47890 798.81704 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
239.25685 798.81704 m
242.69301 798.81704 245.47890 796.03115 245.47890 792.59414 C
245.47890 789.15600 242.69301 786.37011 239.25685 786.37011 C
235.81899 786.37011 233.03310 789.15600 233.03310 792.59414 C
233.03310 796.03115 235.81899 798.81704 239.25685 798.81704 C
@c
S

@rax %Note: Object
177.39156 405.70101 192.80948 416.21839 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
177.84397 415.83118 m
178.02085 415.95109 178.22608 416.01118 178.43187 416.01118 C
178.76183 416.01118 179.09093 415.85698 179.28709 415.57606 C
183.56995 409.64202 L
183.81600 409.30016 184.64088 408.09317 184.91102 407.93499 C
185.34898 407.68101 185.95786 407.72608 186.26995 408.13002 C
186.45506 408.36813 190.92104 415.80595 190.92104 415.80595 C
191.25893 416.24816 191.90806 416.35106 192.37209 416.03499 C
192.83499 415.72120 192.95008 415.09899 192.62183 414.64800 C
192.47499 414.45213 192.32787 414.25512 192.18189 414.05811 C
191.81707 413.56998 188.29502 407.52709 187.83184 407.00409 C
187.42706 406.54715 187.03304 406.19707 186.40885 405.91701 C
186.08598 405.77102 185.77191 405.70101 185.41389 405.70101 C
184.15389 405.70101 183.24085 406.59817 182.57783 407.51802 C
182.19090 408.05320 178.03701 413.81405 177.73909 414.22620 C
177.68494 414.30217 177.62995 414.37701 177.57694 414.45213 C
177.24699 414.90397 177.37087 415.52504 177.84397 415.83118 C
@c
S

@rax %Note: Object
153.60690 405.70101 169.02482 416.21839 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
168.83688 414.64800 m
168.69005 414.45213 168.54293 414.25512 168.39609 414.05811 C
168.03184 413.56998 164.51093 407.52709 164.04803 407.00409 C
163.64183 406.54715 163.24809 406.19707 162.62504 405.91701 C
162.30104 405.77102 161.98696 405.70101 161.62894 405.70101 C
160.36894 405.70101 159.45704 406.59817 158.79288 407.51802 C
158.40709 408.05320 154.25206 413.81405 153.95386 414.22620 C
153.90000 414.30217 153.84586 414.37701 153.79200 414.45213 C
153.46205 414.90397 153.58706 415.52504 154.05789 415.83118 C
154.23704 415.95109 154.44085 416.01118 154.64608 416.01118 C
154.97603 416.01118 155.30683 415.85698 155.50186 415.57606 C
159.78586 409.64202 L
160.03191 409.30016 160.85594 408.09317 161.12693 407.93499 C
161.56403 407.68101 162.14598 407.69206 162.48586 408.13002 C
162.67096 408.36813 167.13609 415.80595 167.13609 415.80595 C
167.47483 416.24816 168.12397 416.35106 168.58687 416.03499 C
169.05005 415.72120 169.16598 415.09899 168.83688 414.64800 C
@c
S

@rax %Note: Object
172.01934 417.53254 174.81685 420.20561 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
172.14094 419.17209 m
173.09991 420.08995 L
173.26290 420.24416 173.52397 420.24416 173.68498 420.08995 C
174.69609 419.12504 L
174.85710 418.97112 174.85710 418.72110 174.69609 418.56605 C
173.73600 417.64819 L
173.57386 417.49398 173.31194 417.49398 173.15093 417.64819 C
172.14094 418.61395 L
171.97909 418.76816 171.97909 419.01817 172.14094 419.17209 C
@c
S

@rax %Note: Object
172.37906 405.67209 174.45798 415.82494 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
172.37906 406.66620 m
172.37906 414.83112 L
172.37906 415.37820 172.84706 415.82494 173.41909 415.82494 C
173.98998 415.82494 174.45798 415.37820 174.45798 414.83112 C
174.45798 406.66620 L
174.45798 406.11912 173.98998 405.67209 173.41909 405.67209 C
172.84706 405.67209 172.37906 406.11912 172.37906 406.66620 C
@c
S

@rax %Note: Object
173.91997 329.35294 194.84901 337.23411 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
194.84901 331.01008 m
194.84901 330.09506 194.10690 329.35294 193.19187 329.35294 C
175.57483 329.35294 L
174.66094 329.35294 173.91997 330.09506 173.91997 331.01008 C
173.91997 333.67918 L
173.91997 334.31017 174.17509 334.91310 174.62891 335.35106 C
176.11795 336.63997 L
176.51197 337.02094 177.03808 337.23411 177.58602 337.23411 C
190.95194 337.23411 L
191.46898 337.23411 191.96787 337.04419 192.35395 336.70120 C
194.06693 335.32809 L
194.56384 334.88702 194.84901 334.25405 194.84901 333.59017 C
194.84901 331.01008 L
@c
S

@rax %Note: Object
194.22907 405.99411 210.43899 416.17020 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
194.22907 410.88501 m
194.22907 411.27902 L
194.22907 413.97506 196.52485 416.17020 199.34787 416.17020 C
205.32189 416.17020 L
208.14293 416.17020 210.43899 413.97506 210.43899 411.27902 C
210.43899 410.88501 L
210.43899 408.18898 208.14293 405.99411 205.32189 405.99411 C
199.34787 405.99411 L
196.52485 405.99411 194.22907 408.18898 194.22907 410.88501 C
@c
S

@rax %Note: Object
201.82706 330.84312 206.24797 335.26403 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
204.03694 330.84312 m
202.81606 330.84312 201.82706 331.83213 201.82706 333.05301 C
201.82706 334.27417 202.81606 335.26403 204.03694 335.26403 C
205.25896 335.26403 206.24797 334.27417 206.24797 333.05301 C
206.24797 331.83213 205.25896 330.84312 204.03694 330.84312 C
@c
S

@rax %Note: Object
207.46091 327.86816 263.18693 337.80217 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
258.22006 327.86816 m
212.42806 327.86816 L
209.68384 327.86816 207.46091 330.09109 207.46091 332.83502 C
207.46091 335.57811 209.68384 337.80217 212.42806 337.80217 C
258.22006 337.80217 L
260.96287 337.80217 263.18693 335.57811 263.18693 332.83502 C
263.18693 330.09109 260.96287 327.86816 258.22006 327.86816 C
@c
S

@rax %Note: Object
114.31984 781.21077 145.80709 793.91849 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
117.44476 782.76076 m
118.02671 781.80265 119.11181 781.21077 120.28592 781.21077 C
130.19868 781.21077 L
139.84044 781.21077 L
141.01483 781.21077 142.09965 781.80265 142.68161 782.76076 C
145.14945 786.82025 L
145.58031 787.52891 145.80709 788.33083 145.80709 789.14665 C
145.80709 792.11906 L
145.80709 793.11231 144.94961 793.91849 143.89313 793.91849 C
130.19868 793.91849 L
116.23351 793.91849 L
115.17676 793.91849 114.31984 793.11231 114.31984 792.11906 C
114.31984 789.14665 L
114.31984 788.33083 114.54718 787.52891 114.97691 786.82025 C
117.44476 782.76076 L
@c
S

@rax %Note: Object
256.44898 330.88195 260.46680 334.89978 @E
/$fm 1 def
 0 O 0 @g
1.0000 1.0000 1.0000  create_rgb_color set_solid_fill
258.45789 334.89978 m
257.34898 334.89978 256.44898 334.00091 256.44898 332.89087 C
256.44898 331.78195 257.34898 330.88195 258.45789 330.88195 C
259.56595 330.88195 260.46680 331.78195 260.46680 332.89087 C
260.46680 334.00091 259.56595 334.89978 258.45789 334.89978 C
@c
F

@rax %Note: Object
256.44898 330.88195 260.46680 334.89978 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
258.45789 334.89978 m
257.34898 334.89978 256.44898 334.00091 256.44898 332.89087 C
256.44898 331.78195 257.34898 330.88195 258.45789 330.88195 C
259.56595 330.88195 260.46680 331.78195 260.46680 332.89087 C
260.46680 334.00091 259.56595 334.89978 258.45789 334.89978 C
@c
S

@rax %Note: Object
196.28646 407.82104 208.47628 414.24123 @E
/$fm 1 def
 0 O 0 @g
1.0000 1.0000 1.0000  create_rgb_color set_solid_fill
208.47628 411.03128 m
208.47628 411.03128 L
208.47628 412.79726 206.96428 414.24123 205.11723 414.24123 C
199.64438 414.24123 L
197.79534 414.24123 196.28646 412.79726 196.28646 411.03128 C
196.28646 409.26529 197.79534 407.82104 199.64438 407.82104 C
205.11723 407.82104 L
206.96428 407.82104 208.47628 409.26529 208.47628 411.03128 C
@c
F

@rax %Note: Object
196.28646 407.82104 208.47628 414.24123 @E
/$fm 1 def
0 J 0 j 22.925585626053735 setmiterlimit
[] 0 d 0 R 0 @G
0.0000 0.0000 0.0000  create_rgb_color set_outline
0 1.00006 1.00006 0.00000 @w
208.47628 411.03128 m
208.47628 411.03128 L
208.47628 412.79726 206.96428 414.24123 205.11723 414.24123 C
199.64438 414.24123 L
197.79534 414.24123 196.28646 412.79726 196.28646 411.03128 C
196.28646 409.26529 197.79534 407.82104 199.64438 407.82104 C
205.11723 407.82104 L
206.96428 407.82104 208.47628 409.26529 208.47628 411.03128 C
@c
S

 @gs spg @gr
%%PageTrailer
@rs
@rs
%%Trailer
@EndSysCorelDict
end
%%DocumentSuppliedResources: procset wCorel21Dict 21.0 0
%%EOF
